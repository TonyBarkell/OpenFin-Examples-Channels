"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const transport_errors_1 = require("../transport/transport-errors");
class OpenFinEnvironment {
    constructor() {
        this.writeToken = (path, token) => {
            throw new transport_errors_1.NotImplementedError('Not Implemented');
        };
        this.retrievePort = (config) => {
            throw new transport_errors_1.NotImplementedError('Not Implemented');
        };
        this.getNextMessageId = () => {
            return fin.desktop.getUuid();
        };
        this.createChildWindow = (options) => {
            return new Promise((resolve, reject) => {
                const { uuid: parentUuid } = fin.__internal_.initialOptions;
                const opt = JSON.parse(JSON.stringify(options));
                const ABOUT_BLANK = 'about:blank';
                if (!name || typeof name !== 'string') {
                    return reject(new Error('Window must have a name'));
                }
                opt.uuid = opt.uuid || parentUuid;
                opt.url = opt.url || ABOUT_BLANK;
                if (opt.uuid !== parentUuid) {
                    return reject(new Error('Child window uuid must match the parent window\'s uuid: ' + parentUuid));
                }
                if (this.isWindowExists(opt.uuid, opt.name)) {
                    return reject(new Error('Trying to create a window that already exists'));
                }
                // we should register the window name with the core asap to prevent
                // multiple windows claiming the same uuid-name combo
                fin.__internal_.registerWindowName(opt.uuid, opt.name);
                if (opt.url !== ABOUT_BLANK) {
                    opt.url = this.resolveUrl(opt.url);
                }
                fin.__internal_.createChildWindow(opt, (childWin) => {
                    resolve(childWin);
                });
            });
        };
        this.getRandomId = () => {
            const intArray = new Uint32Array(1);
            return window.crypto.getRandomValues(intArray)[0].toString(32);
        };
        this.isWindowExists = (uuid, name) => {
            return fin.__internal_.windowExists(uuid, name);
        };
    }
    resolveUrl(url) {
        const newUrl = new URL(url, location.href);
        return newUrl.href;
    }
}
exports.default = OpenFinEnvironment;
//# sourceMappingURL=openfin-env.js.map