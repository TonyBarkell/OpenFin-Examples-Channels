"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = require("../util/promises");
class Base {
    constructor(wire) {
        this.isNodeEnvironment = () => {
            return this.wire.environment.constructor.name === 'NodeEnvironment';
        };
        this.isOpenFinEnvironment = () => {
            return this.wire.environment.constructor.name === 'OpenFinEnvironment';
        };
        this.wire = wire;
    }
    get topic() {
        return this._topic || this.constructor.name.replace('_', '').toLowerCase();
    }
    set topic(t) {
        this._topic = t;
    }
    get me() {
        return this.wire.me;
    }
}
exports.Base = Base;
class EmitterBase extends Base {
    constructor(wire, emitterAccessor) {
        super(wire);
        this.emitterAccessor = emitterAccessor;
        this.eventNames = () => this.hasEmitter() ? this.getEmitter().eventNames() : [];
        this.emit = (eventName, payload, ...args) => {
            return this.hasEmitter()
                ? this.getEmitter().emit(eventName, payload, ...args)
                : false;
        };
        this.hasEmitter = () => this.wire.eventAggregator.has(this.emitterAccessor);
        this.getEmitter = () => this.wire.eventAggregator.get(this.emitterAccessor);
        this.listeners = (type) => this.hasEmitter() ? this.getEmitter().listeners(type) : [];
        this.listenerCount = (type) => this.hasEmitter() ? this.getEmitter().listenerCount(type) : 0;
        this.registerEventListener = async (eventType, options = {}) => {
            const runtimeEvent = Object.assign({}, this.identity, {
                timestamp: options.timestamp || Date.now(),
                topic: this.topic,
                type: eventType
            });
            const emitter = this.getEmitter();
            const refCount = emitter.listenerCount(runtimeEvent.type);
            if (!refCount) {
                await this.wire.sendAction('subscribe-to-desktop-event', runtimeEvent);
            }
            return emitter;
        };
        this.deregisterEventListener = async (eventType, options = {}) => {
            if (this.hasEmitter()) {
                const runtimeEvent = Object.assign({}, this.identity, {
                    timestamp: options.timestamp || Date.now(),
                    topic: this.topic,
                    type: eventType
                });
                const emitter = this.getEmitter();
                const refCount = emitter.listenerCount(runtimeEvent.type);
                const newRefCount = refCount - 1;
                if (newRefCount === 0) {
                    await this.wire.sendAction('unsubscribe-to-desktop-event', runtimeEvent);
                    if (emitter.eventNames && emitter.eventNames().length === 0) {
                        this.wire.eventAggregator.delete(this.emitterAccessor);
                        return;
                    }
                }
                return emitter;
            }
            // This will only be reached if unsubscribe from event that does not exist but do not want to error here
            return Promise.resolve();
        };
        this.on = async (eventType, listener, options) => {
            const emitter = await this.registerEventListener(eventType, options);
            emitter.on(eventType, listener);
            return this;
        };
        this.addListener = this.on;
        this.once = async (eventType, listener, options) => {
            const deregister = () => this.deregisterEventListener(eventType);
            const emitter = await this.registerEventListener(eventType, options);
            emitter.once(eventType, deregister);
            emitter.once(eventType, listener);
            return this;
        };
        this.prependListener = async (eventType, listener, options) => {
            const emitter = await this.registerEventListener(eventType, options);
            emitter.prependListener(eventType, listener);
            return this;
        };
        this.prependOnceListener = async (eventType, listener, options) => {
            const deregister = () => this.deregisterEventListener(eventType);
            const emitter = await this.registerEventListener(eventType, options);
            emitter.prependOnceListener(eventType, listener);
            emitter.once(eventType, deregister);
            return this;
        };
        this.removeListener = async (eventType, listener, options) => {
            const emitter = await this.deregisterEventListener(eventType, options);
            if (emitter) {
                emitter.removeListener(eventType, listener);
            }
            return this;
        };
        this.deregisterAllListeners = async (eventType) => {
            const runtimeEvent = Object.assign({}, this.identity, {
                type: eventType,
                topic: this.topic
            });
            if (this.hasEmitter()) {
                await this.wire.sendAction('unsubscribe-to-desktop-event', runtimeEvent);
                const emitter = this.getEmitter();
                emitter.removeAllListeners(eventType);
                if (emitter.eventNames().length === 0) {
                    this.wire.eventAggregator.delete(this.emitterAccessor);
                    return;
                }
                return emitter;
            }
        };
        this.removeAllListeners = async (eventType) => {
            const removeByEvent = async (event) => {
                const emitter = await this.deregisterAllListeners(event);
                if (emitter) {
                    emitter.removeAllListeners(event);
                }
            };
            if (eventType) {
                await removeByEvent(eventType);
            }
            else if (this.hasEmitter()) {
                const events = this.getEmitter().eventNames();
                await promises_1.promiseMap(events, removeByEvent);
            }
            return this;
        };
        this.listeners = (event) => this.hasEmitter()
            ? this.getEmitter().listeners(event)
            : [];
    }
}
exports.EmitterBase = EmitterBase;
class Reply {
}
exports.Reply = Reply;
//# sourceMappingURL=base.js.map