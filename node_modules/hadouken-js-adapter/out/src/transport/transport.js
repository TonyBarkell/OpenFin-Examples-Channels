"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const wire_1 = require("./wire");
const events_1 = require("events");
const transport_errors_1 = require("./transport-errors");
const eventAggregator_1 = require("../api/events/eventAggregator");
class Transport extends events_1.EventEmitter {
    constructor(wireType, environment) {
        super();
        this.wireListeners = new Map();
        this.topicRefMap = new Map();
        this.eventAggregator = new eventAggregator_1.EventAggregator();
        this.messageHandlers = [this.eventAggregator.dispatchEvent];
        this.connectSync = (config) => {
            const { uuid, name } = config;
            this.me = { uuid, name };
            this.wire.connectSync();
        };
        /* `READY_STATE` is an instance var set by `constructor` to reference the `WebTransportSocket.READY_STATE` enum.
         * This is syntactic sugar that makes the enum accessible through the `wire` property of the various `fin` singletons.
         * For example, `fin.system.wire.READY_STATE` is a shortcut to `fin.system.wire.wire.constructor.READY_STATE`.
         * However it is accessed, the enum is useful for interrogating the state of the web socket on send failure.
         * The `err.readyState` value is passed to the `reject` handler of the promise returned by either of
         * `sendAction` or `ferryAction`, and hence all the API methods in the various `fin` singletons that call them.
         * The enum can be used in two distinct ways by the `reject` handler (using `fin.System.getVersion` by way of example):
         * 1. State name by state value:
         * fin.system.getVersion().catch(err => { console.log('State:', fin.system.wire.READY_STATE[err.readyState]); });
         * 2. State value by state name:
         * fin.system.getVersion().catch(err => { console.log('Closed:', err.readyState === fin.system.wire.READY_STATE.CLOSED); });
         * Note that `reject` is called when and only when `readyState` is not `OPEN`.
         */
        this.READY_STATE = wire_1.READY_STATE;
        this.wire = new wireType(this.onmessage.bind(this));
        this.environment = environment;
        this.sendRaw = this.wire.send.bind(this.wire);
        this.registerMessageHandler(this.handleMessage.bind(this));
        this.wire.on('disconnected', () => {
            for (const [, { reject }] of this.wireListeners) {
                reject('Remote connection has closed');
            }
            this.wireListeners.clear();
            this.emit('disconnected');
        });
    }
    async connect(config) {
        if (wire_1.isExistingConnectConfig(config)) {
            return this.connectByPort(config);
        }
        else if (wire_1.isNewConnectConfig(config)) {
            const port = await this.environment.retrievePort(config);
            return this.connectByPort(Object.assign({}, config, { address: `ws://localhost:${port}` }));
        }
    }
    async connectByPort(config) {
        const { address, uuid, name } = config;
        const reqAuthPayload = Object.assign({}, config, { type: 'file-token' });
        this.me = { uuid, name };
        await this.wire.connect(address);
        const requestExtAuthRet = await this.sendAction('request-external-authorization', {
            uuid,
            type: 'file-token'
        }, true);
        if (requestExtAuthRet.action !== 'external-authorization-response') {
            throw new transport_errors_1.UnexpectedActionError(requestExtAuthRet.action);
        }
        const token = requestExtAuthRet.payload.token;
        await this.environment.writeToken(requestExtAuthRet.payload.file, requestExtAuthRet.payload.token);
        const requestAuthRet = await this.sendAction('request-authorization', reqAuthPayload, true);
        if (requestAuthRet.action !== 'authorization-response') {
            throw new transport_errors_1.UnexpectedActionError(requestAuthRet.action);
        }
        else if (requestAuthRet.payload.success !== true) {
            throw new transport_errors_1.RuntimeError(requestAuthRet.payload);
        }
        else {
            return token;
        }
    }
    sendAction(action, payload = {}, uncorrelated = false) {
        return new Promise((resolve, reject) => {
            const id = this.environment.getNextMessageId();
            const msg = {
                action,
                payload,
                messageId: id
            };
            return this.wire.send(msg)
                .then(() => this.addWireListener(id, resolve, reject, uncorrelated))
                .catch(reject);
        });
    }
    ferryAction(data) {
        return new Promise((resolve, reject) => {
            const id = this.environment.getNextMessageId();
            data.messageId = id;
            const resolver = (data) => { resolve(data.payload); };
            return this.wire.send(data)
                .then(() => this.addWireListener(id, resolver, reject, false))
                .catch(reject);
        });
    }
    registerMessageHandler(handler) {
        this.messageHandlers.push(handler);
    }
    addWireListener(id, resolve, reject, uncorrelated) {
        if (uncorrelated) {
            this.uncorrelatedListener = resolve;
        }
        else if (this.wireListeners.has(id)) {
            reject(new transport_errors_1.DuplicateCorrelationError(String(id)));
        }
        else {
            this.wireListeners.set(id, { resolve, reject });
        }
        // Timeout and reject()?
    }
    // This method executes message handlers until the _one_ that handles the message (returns truthy) has run
    onmessage(data) {
        for (const h of this.messageHandlers) {
            h.call(null, data);
        }
    }
    handleMessage(data) {
        // tslint:disable-next-line
        const id = data.correlationId || NaN;
        if (!('correlationId' in data)) {
            if (this.uncorrelatedListener) {
                this.uncorrelatedListener.call(null, data);
            }
            // tslint:disable-next-line
            this.uncorrelatedListener = () => { };
        }
        else if (!this.wireListeners.has(id)) {
            return false;
        }
        else {
            const { resolve, reject } = this.wireListeners.get(id);
            if (data.action !== 'ack') {
                reject(new transport_errors_1.NoAckError(data.action));
            }
            else if (!('payload' in data)) {
                reject(new transport_errors_1.RuntimeError(data));
            }
            else if (!data.payload.success) {
                reject(new transport_errors_1.RuntimeError(data.payload));
            }
            else {
                resolve.call(null, data);
            }
            this.wireListeners.delete(id);
        }
        return true;
    }
}
exports.default = Transport;
class Message {
}
exports.Message = Message;
class EventMessage {
}
exports.EventMessage = EventMessage;
class NotificationEventMessage {
}
exports.NotificationEventMessage = NotificationEventMessage;
class Payload {
}
exports.Payload = Payload;
class AuthorizationPayload {
}
exports.AuthorizationPayload = AuthorizationPayload;
//# sourceMappingURL=transport.js.map