"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const https = require("https");
const fs = require("fs");
const child_process_1 = require("child_process");
const promises_1 = require("../util/promises");
const stat = promises_1.promisify(fs.stat);
async function exists(path) {
    try {
        const exists = await stat(path);
        return Boolean(exists);
    }
    catch (e) {
        return false;
    }
}
exports.exists = exists;
async function get(url) {
    return new Promise((resolve, reject) => {
        const request = https.get(url, (response) => {
            if (response.statusCode < 200 || response.statusCode > 299) {
                reject(new Error('Failed to load page, status code: ' + response.statusCode));
            }
            const body = [];
            response.on('data', (chunk) => {
                body.push(chunk);
            });
            response.on('end', () => resolve(body.join('')));
        });
        request.on('error', (err) => reject(err));
    });
}
exports.get = get;
async function unzip(file, dest) {
    const ex = promises_1.promisify(child_process_1.exec);
    return ex(`unzip ${file} -d ${dest}`, { encoding: 'utf8' });
}
exports.unzip = unzip;
const lstat = promises_1.promisify(fs.lstat);
const unlink = promises_1.promisify(fs.unlink);
const readdir = promises_1.promisify(fs.readdir);
const rmdir = promises_1.promisify(fs.rmdir);
async function rmDir(dirPath, removeSelf = true) {
    let files;
    try {
        files = await readdir(dirPath);
    }
    catch (e) {
        return;
    }
    if (files.length > 0) {
        await promises_1.promiseMap(files, async (f) => {
            const filePath = dirPath + '/' + f;
            const file = await lstat(filePath);
            if (file.isFile() || file.isSymbolicLink()) {
                await unlink(filePath);
            }
            else {
                await rmDir(filePath, true);
            }
        });
    }
    if (removeSelf) {
        await rmdir(dirPath);
    }
}
exports.rmDir = rmDir;
async function downloadFile(url, writeLocation) {
    return new Promise((resolve, reject) => {
        try {
            https.get(url, (response) => {
                if (response.statusCode !== 200) {
                    if (response.statusCode === 404) {
                        reject(new Error('Specified runtime not available for OS'));
                    }
                    else {
                        reject(new Error('Issue Downloading ' + response.statusCode));
                    }
                }
                else {
                    const file = fs.createWriteStream(writeLocation);
                    response.pipe(file);
                    file.on('finish', () => {
                        file.close();
                        resolve();
                    });
                }
            });
        }
        catch (e) {
            reject(e);
        }
    });
}
exports.downloadFile = downloadFile;
async function resolveRuntimeVersion(versionOrChannel) {
    const splitVersion = versionOrChannel.split('.');
    const isVersion = splitVersion.length > 1 && splitVersion.every(x => x === '*' || /^\d+$/.test(x));
    if (isVersion) {
        const mustMatch = takeWhile(splitVersion, (x) => x !== '*');
        if (4 - mustMatch.length > 0) {
            //    tslint:disable-next-line:no-backbone-get-set-outside-model
            const res = await get('https://cdn.openfin.co/release/runtimeVersions');
            const versions = res.split('\r\n');
            const match = first(versions, (v) => v.split('.').slice(0, mustMatch.length).join('.') === mustMatch.join('.'));
            if (match) {
                return match;
            }
        }
        else {
            return versionOrChannel;
        }
    }
    try {
        // tslint:disable-next-line:no-backbone-get-set-outside-model
        return await get(`https://cdn.openfin.co/release/runtime/${versionOrChannel}`);
    }
    catch (err) {
        throw Error('Could not resolve runtime version');
    }
}
exports.resolveRuntimeVersion = resolveRuntimeVersion;
function first(arr, func) {
    // tslint:disable-next-line:no-increment-decrement
    for (let i = 0; i < arr.length; i++) {
        if (func(arr[i], i, arr)) {
            return arr[i];
        }
    }
    return null;
}
exports.first = first;
function takeWhile(arr, func) {
    return arr.reduce(({ take, vals }, x, i, r) => take && func(x, i, r)
        ? { take: true, vals: [...vals, x] }
        : { take: false, vals }, { take: true, vals: [] })
        .vals;
}
const mkdir = promises_1.promisify(fs.mkdir);
async function resolveDir(base, paths) {
    return await paths.reduce(async (p, next) => {
        try {
            const prev = await p;
            await mkdir(path.resolve(prev, next));
            return path.join(prev, next);
        }
        catch (err) {
            return err.code === 'EEXIST' ? err.path : Promise.reject(err);
        }
    }, Promise.resolve(base));
}
exports.resolveDir = resolveDir;
//# sourceMappingURL=util.js.map