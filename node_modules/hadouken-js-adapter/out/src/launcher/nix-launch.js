"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const child_process_1 = require("child_process");
const promises_1 = require("../util/promises");
const util_1 = require("./util");
const mkdir = promises_1.promisify(fs.mkdir);
const downloads = {};
function getUrl(version, urlPath) {
    const runtimeRoot = process.env.assetsUrl || 'https://cdn.openfin.co/release/runtime/';
    return `${runtimeRoot}${urlPath}/${version}`;
}
exports.getUrl = getUrl;
async function download(version, folder, osConfig) {
    const url = getUrl(version, osConfig.urlPath);
    const tmp = 'tmp';
    await util_1.rmDir(folder, false);
    // tslint:disable-next-line:no-empty
    await mkdir(path.join(folder, tmp)).catch(e => { });
    const file = path.join(folder, tmp, 'tmp');
    await util_1.downloadFile(url, file);
    await util_1.unzip(file, folder);
    await util_1.rmDir(path.join(folder, tmp), true);
    return folder;
}
exports.download = download;
async function getRuntimePath(version) {
    if (process.env.runtimeDirectory) {
        return util_1.resolveDir(process.env.runtimeDirectory, ['Runtime', version]);
    }
    const versionPath = ['OpenFin', 'Runtime', version];
    const HOME = process.env.HOME;
    return util_1.resolveDir(HOME, versionPath);
}
exports.getRuntimePath = getRuntimePath;
async function install(versionOrChannel, osConfig) {
    const version = await util_1.resolveRuntimeVersion(versionOrChannel);
    const rtFolder = await getRuntimePath(version);
    const rtPath = path.join(rtFolder, osConfig.executablePath);
    const rtExists = await util_1.exists(rtPath);
    if (Boolean(rtExists)) {
        await promises_1.promisify(fs.chmod)(rtPath, 0o755);
    }
    else {
        try {
            if (!downloads[version]) {
                downloads[version] = download(version, rtFolder, osConfig);
            }
            await downloads[version];
            downloads[version] = undefined;
        }
        catch (err) {
            console.error(`Failed to download, attempting to empty ${rtFolder}`);
            await util_1.rmDir(rtFolder, false);
            throw Error(`Could not install runtime ${versionOrChannel} (${version})`);
        }
    }
    return rtPath;
}
exports.install = install;
async function launch(config, osConfig) {
    try {
        let fb = false;
        const runtimePath = await install(config.runtime.version, osConfig)
            .catch(e => {
            if (config.runtime.fallbackVersion !== undefined) {
                fb = true;
                console.warn(`could not install openfin ${config.runtime.version}`);
                console.warn(`trying fallback ${config.runtime.fallbackVersion}`);
                return install(config.runtime.fallbackVersion, osConfig);
            }
            return Promise.reject(e);
        });
        const args = config.runtime.arguments ? config.runtime.arguments.split(' ') : [];
        if (process.env.runtimeArgs) {
            args.push(process.env.runtimeArgs.split(' '));
        }
        args.unshift(`--startup-url=${osConfig.manifestLocation}`);
        args.push(`--version-keyword=${fb ? config.runtime.fallbackVersion : config.runtime.version}`);
        args.push(`--runtime-information-channel-v6=${osConfig.namedPipeName}`);
        if (config.runtime.securityRealm) {
            args.push(`--security-realm=${config.runtime.securityRealm}`);
        }
        if (config.runtime.verboseLogging) {
            args.push('--v=1');
            args.push('--attach-console');
        }
        return child_process_1.spawn(runtimePath, args);
    }
    catch (e) {
        console.error('Failed to launch\n', e);
        throw e;
    }
}
exports.default = launch;
//# sourceMappingURL=nix-launch.js.map