/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/of-main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/api/application/application.ts":
/*!********************************************!*\
  !*** ./src/api/application/application.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\nconst window_1 = __webpack_require__(/*! ../window/window */ \"./src/api/window/window.ts\");\nclass NavigationRejectedReply extends base_1.Reply {\n}\nexports.NavigationRejectedReply = NavigationRejectedReply;\n/**\n * @lends Application\n */\nclass ApplicationModule extends base_1.Base {\n    /**\n     * Asynchronously returns an Application object that represents an existing application.\n     * @param { Identity } identity\n     * @return {Promise.<Application>}\n     * @tutorial Application.wrap\n     * @static\n     */\n    wrap(identity) {\n        return Promise.resolve(new Application(this.wire, identity));\n    }\n    /**\n     * Synchronously returns an Application object that represents an existing application.\n     * @param { Identity } identity\n     * @return {Application}\n     * @tutorial Application.wrapSync\n     * @static\n     */\n    wrapSync(identity) {\n        return new Application(this.wire, identity);\n    }\n    /**\n     * Creates a new Application.\n     * @param { ApplicationOption } appOptions\n     * @return {Promise.<Application>}\n     * @tutorial Application.create\n     * @static\n     */\n    create(appOptions) {\n        return this.wire.sendAction('create-application', appOptions)\n            .then(() => this.wrap({ uuid: appOptions.uuid }));\n    }\n    /**\n     * Asynchronously returns an Application object that represents the current application\n     * @return {Promise.<Application>}\n     * @tutorial Application.getCurrent\n     * @static\n     */\n    getCurrent() {\n        return this.wrap({ uuid: this.wire.me.uuid });\n    }\n    /**\n     * Synchronously returns an Application object that represents the current application\n     * @return {Application}\n     * @tutorial Application.getCurrentSync\n     * @static\n     */\n    getCurrentSync() {\n        return this.wrapSync({ uuid: this.wire.me.uuid });\n    }\n    /**\n     * Retrieves application's manifest and returns a wrapped application.\n     * @param {string} manifestUrl - The URL of app's manifest.\n     * @return {Promise.<Application>}\n     * @tutorial Application.createFromManifest\n     * @static\n     */\n    createFromManifest(manifestUrl) {\n        return this.wire.sendAction('get-application-manifest', { manifestUrl })\n            .then(({ payload }) => this.wrap({ uuid: payload.data.startup_app.uuid })\n            .then(app => {\n            app._manifestUrl = manifestUrl;\n            return app;\n        }));\n    }\n}\nexports.default = ApplicationModule;\n/**\n * @classdesc An object representing an application. Allows the developer to create,\n * execute, show/close an application as well as listen to application events.\n * @class\n */\nclass Application extends base_1.EmitterBase {\n    constructor(wire, identity) {\n        super(wire, ['application', identity.uuid]);\n        this.identity = identity;\n        this.window = new window_1._Window(this.wire, {\n            uuid: this.identity.uuid,\n            name: this.identity.uuid\n        });\n    }\n    windowListFromIdentityList(identityList) {\n        const windowList = [];\n        identityList.forEach(identity => {\n            windowList.push(new window_1._Window(this.wire, {\n                uuid: identity.uuid,\n                name: identity.name\n            }));\n        });\n        return windowList;\n    }\n    /**\n     * Determines if the application is currently running.\n     * @return {Promise.<boolean>}\n     * @tutorial Application.isRunning\n     */\n    isRunning() {\n        return this.wire.sendAction('is-application-running', this.identity)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Closes the application and any child windows created by the application.\n     * @param { boolean } [force = false] Close will be prevented from closing when force is false and\n     *  close-requested has been subscribed to for applications main window.\n     * @return {Promise.<boolean>}\n     * @tutorial Application.close\n     */\n    close(force = false) {\n        return this.wire.sendAction('close-application', Object.assign({}, this.identity, { force })).then(() => undefined);\n    }\n    /**\n     * Retrieves an array of wrapped fin.Windows for each of the applications child windows.\n     * @return {Promise.Array.<_Window>}\n     * @tutorial Application.getChildWindows\n     */\n    getChildWindows() {\n        return this.wire.sendAction('get-child-windows', this.identity)\n            .then(({ payload }) => {\n            const identityList = [];\n            payload.data.forEach((winName) => {\n                identityList.push({ uuid: this.identity.uuid, name: winName });\n            });\n            return this.windowListFromIdentityList(identityList);\n        });\n    }\n    /**\n     * Retrieves an array of active window groups for all of the application's windows. Each group is\n     * represented as an array of wrapped fin.Windows.\n     * @return {Promise.Array.Array.<_Window>}\n     * @tutorial Application.getGroups\n     */\n    getGroups() {\n        const winGroups = [];\n        return this.wire.sendAction('get-application-groups', Object.assign({}, this.identity, {\n            crossApp: true // cross app group supported\n        })).then(({ payload }) => {\n            payload.data.forEach((windowList, index) => {\n                const identityList = [];\n                windowList.forEach(winInfo => {\n                    identityList.push({ uuid: winInfo.uuid, name: winInfo.windowName });\n                });\n                winGroups[index] = this.windowListFromIdentityList(identityList);\n            });\n            return winGroups;\n        });\n    }\n    /**\n     * Retrieves the JSON manifest that was used to create the application. Invokes the error callback\n     * if the application was not created from a manifest.\n     * @return {Promise.<any>}\n     * @tutorial Application.getManifest\n     */\n    getManifest() {\n        return this.wire.sendAction('get-application-manifest', this.identity)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves UUID of the application that launches this application. Invokes the error callback\n     * if the application was created from a manifest.\n     * @return {Promise.<string>}\n     * @tutorial Application.getParentUuid\n     */\n    getParentUuid() {\n        return this.wire.sendAction('get-parent-application', this.identity)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves current application's shortcut configuration.\n     * @return {Promise.<ShortCutConfig>}\n     * @tutorial Application.getShortcuts\n     */\n    getShortcuts() {\n        return this.wire.sendAction('get-shortcuts', this.identity)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Returns the current zoom level of the application.\n     * @return {Promise.<number>}\n     * @tutorial Application.getZoomLevel\n     */\n    getZoomLevel() {\n        return this.wire.sendAction('get-application-zoom-level', this.identity).then(({ payload }) => payload.data);\n    }\n    /**\n     * Returns an instance of the main Window of the application\n     * @return {Promise.<_Window>}\n     * @tutorial Application.getWindow\n     */\n    getWindow() {\n        return Promise.resolve(this.window);\n    }\n    /**\n    * Manually registers a user with the licensing service. The only data sent by this call is userName and appName.\n    * @param { string } userName - username to be passed to the RVM.\n    * @param { string } appName - app name to be passed to the RVM.\n    * @return {Promise.<void>}\n    * @tutorial Application.registerUser\n    */\n    registerUser(userName, appName) {\n        return this.wire.sendAction('register-user', Object.assign({}, this.identity, { userName, appName })).then(() => undefined);\n    }\n    /**\n     * Removes the applications icon from the tray.\n     * @return {Promise.<void>}\n     * @tutorial Application.removeTrayIcon\n     */\n    removeTrayIcon() {\n        return this.wire.sendAction('remove-tray-icon', this.identity).then(() => undefined);\n    }\n    /**\n     * Restarts the application.\n     * @return {Promise.<void>}\n     * @tutorial Application.restart\n     */\n    restart() {\n        return this.wire.sendAction('restart-application', this.identity).then(() => undefined);\n    }\n    /**\n     * Runs the application. When the application is created, run must be called.\n     * @return {Promise.<void>}\n     * @tutorial Application.run\n     */\n    run() {\n        return this.wire.sendAction('run-application', Object.assign({}, this.identity, {\n            manifestUrl: this._manifestUrl\n        })).then(() => undefined);\n    }\n    /**\n     * Instructs the RVM to schedule one restart of the application.\n     * @return {Promise.<void>}\n     * @tutorial Application.scheduleRestart\n     */\n    scheduleRestart() {\n        return this.wire.sendAction('relaunch-on-close', this.identity).then(() => undefined);\n    }\n    /**\n     * Sends a message to the RVM to upload the application's logs. On success,\n     * an object containing logId is returned.\n     * @return {Promise.<any>}\n     * @tutorial Application.sendApplicationLog\n     */\n    async sendApplicationLog() {\n        const { payload } = await this.wire.sendAction('send-application-log', this.identity);\n        return payload.data;\n    }\n    /**\n     * Adds a customizable icon in the system tray and notifies the application when clicked.\n     * @param { string } iconUrl Image URL to be used as the icon\n     * @return {Promise.<void>}\n     * @tutorial Application.setTrayIcon\n     */\n    setTrayIcon(iconUrl) {\n        return this.wire.sendAction('set-tray-icon', Object.assign({}, this.identity, {\n            enabledIcon: iconUrl\n        })).then(() => undefined);\n    }\n    /**\n     * Sets new application's shortcut configuration.\n     * @param { Object } config New application's shortcut configuration.\n     * @param {Boolean} [config.desktop] - Enable/disable desktop shortcut.\n     * @param {Boolean} [config.startMenu] - Enable/disable start menu shortcut.\n     * @param {Boolean} [config.systemStartup] - Enable/disable system startup shortcut.\n     * @return {Promise.<void>}\n     * @tutorial Application.setShortcuts\n     */\n    setShortcuts(config) {\n        return this.wire.sendAction('set-shortcuts', Object.assign({}, this.identity, { data: config })).then(() => undefined);\n    }\n    /**\n     * Sets the zoom level of the application. The original size is 0 and each increment above or below represents zooming 20%\n     * larger or smaller to default limits of 300% and 50% of original size, respectively.\n     * @param { number } level The zoom level\n     * @return {Promise.<void>}\n     * @tutorial Application.setZoomLevel\n     */\n    setZoomLevel(level) {\n        return this.wire.sendAction('set-application-zoom-level', Object.assign({}, this.identity, { level })).then(() => undefined);\n    }\n    /**\n     * Sets a username to correlate with App Log Management.\n     * @param { string } username Username to correlate with App's Log.\n     * @return {Promise.<void>}\n     * @tutorial Application.setAppLogUsername\n     */\n    async setAppLogUsername(username) {\n        await this.wire.sendAction('set-app-log-username', Object.assign({ data: username }, this.identity));\n    }\n    /**\n     * @summary Retrieves information about the system tray.\n     * @desc The only information currently returned is the position and dimensions.\n     * @return {Promise.<TrayInfo>}\n     * @tutorial Application.getTrayIconInfo\n     */\n    getTrayIconInfo() {\n        return this.wire.sendAction('get-tray-icon-info', this.identity)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Closes the application by terminating its process.\n     * @return {Promise.<void>}\n     * @tutorial Application.terminate\n     */\n    terminate() {\n        return this.wire.sendAction('terminate-application', this.identity).then(() => undefined);\n    }\n    /**\n     * Waits for a hanging application. This method can be called in response to an application\n     * \"not-responding\" to allow the application to continue and to generate another \"not-responding\"\n     * message after a certain period of time.\n     * @return {Promise.<void>}\n     * @ignore\n     */\n    wait() {\n        return this.wire.sendAction('wait-for-hung-application', this.identity).then(() => undefined);\n    }\n    /**\n     * Retrieves information about the application.\n     * @return {Promise.<ApplicationInfo>}\n     * @tutorial Application.getInfo\n     */\n    getInfo() {\n        return this.wire.sendAction('get-info', this.identity).then(({ payload }) => payload.data);\n    }\n}\nexports.Application = Application;\n\n\n//# sourceURL=webpack:///./src/api/application/application.ts?");

/***/ }),

/***/ "./src/api/base.ts":
/*!*************************!*\
  !*** ./src/api/base.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst promises_1 = __webpack_require__(/*! ../util/promises */ \"./src/util/promises.ts\");\nclass Base {\n    constructor(wire) {\n        this.isNodeEnvironment = () => {\n            return this.wire.environment.constructor.name === 'NodeEnvironment';\n        };\n        this.isOpenFinEnvironment = () => {\n            return this.wire.environment.constructor.name === 'OpenFinEnvironment';\n        };\n        this.wire = wire;\n    }\n    get topic() {\n        return this._topic || this.constructor.name.replace('_', '').toLowerCase();\n    }\n    set topic(t) {\n        this._topic = t;\n    }\n    get me() {\n        return this.wire.me;\n    }\n}\nexports.Base = Base;\nclass EmitterBase extends Base {\n    constructor(wire, emitterAccessor) {\n        super(wire);\n        this.emitterAccessor = emitterAccessor;\n        this.eventNames = () => this.hasEmitter() ? this.getEmitter().eventNames() : [];\n        this.emit = (eventName, payload, ...args) => {\n            return this.hasEmitter()\n                ? this.getEmitter().emit(eventName, payload, ...args)\n                : false;\n        };\n        this.hasEmitter = () => this.wire.eventAggregator.has(this.emitterAccessor);\n        this.getEmitter = () => this.wire.eventAggregator.get(this.emitterAccessor);\n        this.listeners = (type) => this.hasEmitter() ? this.getEmitter().listeners(type) : [];\n        this.listenerCount = (type) => this.hasEmitter() ? this.getEmitter().listenerCount(type) : 0;\n        this.registerEventListener = async (eventType, options = {}) => {\n            const runtimeEvent = Object.assign({}, this.identity, {\n                timestamp: options.timestamp || Date.now(),\n                topic: this.topic,\n                type: eventType\n            });\n            const emitter = this.getEmitter();\n            const refCount = emitter.listenerCount(runtimeEvent.type);\n            if (!refCount) {\n                await this.wire.sendAction('subscribe-to-desktop-event', runtimeEvent);\n            }\n            return emitter;\n        };\n        this.deregisterEventListener = async (eventType, options = {}) => {\n            if (this.hasEmitter()) {\n                const runtimeEvent = Object.assign({}, this.identity, {\n                    timestamp: options.timestamp || Date.now(),\n                    topic: this.topic,\n                    type: eventType\n                });\n                const emitter = this.getEmitter();\n                const refCount = emitter.listenerCount(runtimeEvent.type);\n                const newRefCount = refCount - 1;\n                if (newRefCount === 0) {\n                    await this.wire.sendAction('unsubscribe-to-desktop-event', runtimeEvent);\n                    if (emitter.eventNames && emitter.eventNames().length === 0) {\n                        this.wire.eventAggregator.delete(this.emitterAccessor);\n                        return;\n                    }\n                }\n                return emitter;\n            }\n            // This will only be reached if unsubscribe from event that does not exist but do not want to error here\n            return Promise.resolve();\n        };\n        this.on = async (eventType, listener, options) => {\n            const emitter = await this.registerEventListener(eventType, options);\n            emitter.on(eventType, listener);\n            return this;\n        };\n        this.addListener = this.on;\n        this.once = async (eventType, listener, options) => {\n            const deregister = () => this.deregisterEventListener(eventType);\n            const emitter = await this.registerEventListener(eventType, options);\n            emitter.once(eventType, deregister);\n            emitter.once(eventType, listener);\n            return this;\n        };\n        this.prependListener = async (eventType, listener, options) => {\n            const emitter = await this.registerEventListener(eventType, options);\n            emitter.prependListener(eventType, listener);\n            return this;\n        };\n        this.prependOnceListener = async (eventType, listener, options) => {\n            const deregister = () => this.deregisterEventListener(eventType);\n            const emitter = await this.registerEventListener(eventType, options);\n            emitter.prependOnceListener(eventType, listener);\n            emitter.once(eventType, deregister);\n            return this;\n        };\n        this.removeListener = async (eventType, listener, options) => {\n            const emitter = await this.deregisterEventListener(eventType, options);\n            if (emitter) {\n                emitter.removeListener(eventType, listener);\n            }\n            return this;\n        };\n        this.deregisterAllListeners = async (eventType) => {\n            const runtimeEvent = Object.assign({}, this.identity, {\n                type: eventType,\n                topic: this.topic\n            });\n            if (this.hasEmitter()) {\n                await this.wire.sendAction('unsubscribe-to-desktop-event', runtimeEvent);\n                const emitter = this.getEmitter();\n                emitter.removeAllListeners(eventType);\n                if (emitter.eventNames().length === 0) {\n                    this.wire.eventAggregator.delete(this.emitterAccessor);\n                    return;\n                }\n                return emitter;\n            }\n        };\n        this.removeAllListeners = async (eventType) => {\n            const removeByEvent = async (event) => {\n                const emitter = await this.deregisterAllListeners(event);\n                if (emitter) {\n                    emitter.removeAllListeners(event);\n                }\n            };\n            if (eventType) {\n                await removeByEvent(eventType);\n            }\n            else if (this.hasEmitter()) {\n                const events = this.getEmitter().eventNames();\n                await promises_1.promiseMap(events, removeByEvent);\n            }\n            return this;\n        };\n        this.listeners = (event) => this.hasEmitter()\n            ? this.getEmitter().listeners(event)\n            : [];\n    }\n}\nexports.EmitterBase = EmitterBase;\nclass Reply {\n}\nexports.Reply = Reply;\n\n\n//# sourceURL=webpack:///./src/api/base.ts?");

/***/ }),

/***/ "./src/api/clipboard/clipboard.ts":
/*!****************************************!*\
  !*** ./src/api/clipboard/clipboard.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\n/**\n * WriteRequestType interface\n * @typedef { Object } WriteRequestType\n * @property { string } name The name of the running application\n * @property { string } uuid The uuid of the running application\n */\n/**\n * The Clipboard API allows reading and writing to the clipboard in multiple formats.\n * @namespace\n*/\nclass Clipboard extends base_1.Base {\n    /**\n     * Writes data into the clipboard as plain text\n     * @param { WriteRequestType } writeObj This object is described in the WriteRequestType typeof\n     * @return {Promise.<void>}\n     * @tutorial Clipboard.writeText\n    */\n    writeText(writeObj) {\n        return this.wire.sendAction('clipboard-write-text', writeObj).then(() => undefined);\n    }\n    /**\n     * Read the content of the clipboard as plain text\n     * @param { string } type Clipboard Type\n     * @return {Promise.<string>}\n     * @tutorial Clipboard.readText\n    */\n    readText(type) {\n        return this.wire.sendAction('clipboard-read-text', type)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Writes data into the clipboard as Html\n     * @param { WriteRequestType } writeObj This object is described in the WriteRequestType typedef\n     * @return {Promise.<void>}\n     * @tutorial Clipboard.writeHtml\n    */\n    writeHtml(writeObj) {\n        return this.wire.sendAction('clipboard-write-html', writeObj).then(() => undefined);\n    }\n    /**\n     * Read the content of the clipboard as Html\n     * @param { string } type Clipboard Type\n     * @return {Promise.<string>}\n     * @tutorial Clipboard.readHtml\n    */\n    readHtml(type) {\n        return this.wire.sendAction('clipboard-read-html', type)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Writes data into the clipboard as Rtf\n     * @param { WriteRequestType } writeObj This object is described in the WriteRequestType typedef\n     * @return {Promise.<void>}\n     * @tutorial Clipboard.writeRtf\n    */\n    writeRtf(writeObj) {\n        return this.wire.sendAction('clipboard-write-rtf', writeObj).then(() => undefined);\n    }\n    /**\n     * Read the content of the clipboard as Rtf\n     * @param { string } type Clipboard Type\n     * @return {Promise.<string>}\n     * @tutorial Clipboard.readRtf\n    */\n    readRtf(type) {\n        return this.wire.sendAction('clipboard-read-rtf', type)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Writes data into the clipboard\n     * @param { WriteRequestType } writeObj This object is described in the WriteRequestType typedef\n     * @return {Promise.<void>}\n     * @tutorial Clipboard.write\n    */\n    write(writeObj) {\n        return this.wire.sendAction('clipboard-write', writeObj).then(() => undefined);\n    }\n    /**\n     * Reads available formats for the clipboard type\n     * @param { string } type Clipboard Type\n     * @return {Promise.Array.<string>}\n     * @tutorial Clipboard.getAvailableFormats\n    */\n    getAvailableFormats(type) {\n        return this.wire.sendAction('clipboard-read-formats', type)\n            .then(({ payload }) => payload.data);\n    }\n}\nexports.default = Clipboard;\n\n\n//# sourceURL=webpack:///./src/api/clipboard/clipboard.ts?");

/***/ }),

/***/ "./src/api/events/emitterMap.ts":
/*!**************************************!*\
  !*** ./src/api/events/emitterMap.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nclass EmitterMap {\n    constructor() {\n        this.storage = new Map();\n    }\n    hashKeys(keys) {\n        const hashed = keys.map(normalizeString);\n        return hashed.join('/');\n    }\n    get(keys) {\n        const hash = this.hashKeys(keys);\n        if (!this.storage.has(hash)) {\n            this.storage.set(hash, new events_1.EventEmitter());\n        }\n        return this.storage.get(hash);\n    }\n    has(keys) {\n        return this.storage.has(this.hashKeys(keys));\n    }\n    delete(keys) {\n        const hash = this.hashKeys(keys);\n        return this.storage.delete(hash);\n    }\n}\nexports.EmitterMap = EmitterMap;\nfunction normalizeString(s) {\n    const b = new Buffer(s);\n    return b.toString('base64');\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./src/api/events/emitterMap.ts?");

/***/ }),

/***/ "./src/api/events/eventAggregator.ts":
/*!*******************************************!*\
  !*** ./src/api/events/eventAggregator.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst emitterMap_1 = __webpack_require__(/*! ./emitterMap */ \"./src/api/events/emitterMap.ts\");\nfunction isEventMessage(message) {\n    return message.action === 'process-desktop-event';\n}\nfunction isNotificationMessage(message) {\n    return message.action === 'process-notification-event';\n}\nconst buildLocalPayload = (rawPayload) => {\n    const { payload: { message }, type } = rawPayload;\n    const payload = {};\n    switch (type) {\n        case 'message':\n            payload.message = message;\n            break;\n        case 'show':\n        case 'error':\n        case 'click':\n        case 'close':\n        default: break;\n    }\n    return payload;\n};\nfunction mapKeyFromEvent(event) {\n    const { topic } = event;\n    if (topic === 'frame') {\n        const { uuid, name } = event;\n        return [topic, uuid, name];\n    }\n    if (topic === 'window') {\n        const { uuid, name } = event;\n        return [topic, uuid, name];\n    }\n    if (topic === 'application') {\n        const { uuid } = event;\n        return [topic, uuid];\n    }\n    return [topic];\n}\nclass EventAggregator extends emitterMap_1.EmitterMap {\n    constructor() {\n        super(...arguments);\n        this.dispatchEvent = (message) => {\n            if (isEventMessage(message)) {\n                const { payload } = message;\n                const accessor = mapKeyFromEvent(payload);\n                if (this.has(accessor)) {\n                    this.get(accessor).emit(payload.type, payload);\n                    return true;\n                }\n            }\n            else if (isNotificationMessage(message)) {\n                const { payload: { notificationId }, type } = message.payload;\n                const accessor = ['notification', '' + notificationId];\n                if (this.has(accessor)) {\n                    this.get(accessor).emit(type, buildLocalPayload(message.payload));\n                    return true;\n                }\n            }\n            return false;\n        };\n    }\n}\nexports.EventAggregator = EventAggregator;\n\n\n//# sourceURL=webpack:///./src/api/events/eventAggregator.ts?");

/***/ }),

/***/ "./src/api/external-application/external-application.ts":
/*!**************************************************************!*\
  !*** ./src/api/external-application/external-application.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\n/**\n * @lends ExternalApplication\n */\nclass ExternalApplicationModule extends base_1.Base {\n    /**\n     * Asynchronously returns an External Application object that represents an existing external application.\n     * @param {string} uuid The UUID of the external application to be wrapped\n     * @return {Promise.<ExternalApplication>}\n     * @tutorial ExternalApplication.wrap\n     * @static\n     */\n    wrap(uuid) {\n        return Promise.resolve(new ExternalApplication(this.wire, { uuid }));\n    }\n    /**\n     * Synchronously returns an External Application object that represents an existing external application.\n     * @param {string} uuid The UUID of the external application to be wrapped\n     * @return {ExternalApplication}\n     * @tutorial ExternalApplication.wrapSync\n     * @static\n     */\n    wrapSync(uuid) {\n        return new ExternalApplication(this.wire, { uuid });\n    }\n}\nexports.default = ExternalApplicationModule;\n/**\n * @classdesc An ExternalApplication object representing an application. Allows\n * the developer to create, execute, show and close an external application as\n * well as listen to application events.\n * @class\n */\nclass ExternalApplication extends base_1.EmitterBase {\n    constructor(wire, identity) {\n        super(wire, ['external-application', identity.uuid]);\n        this.identity = identity;\n    }\n    /**\n     * Retrieves information about the external application.\n     * @return {Promise.<ExternalApplicationInfo>}\n     * @tutorial ExternalApplication.getInfo\n     */\n    getInfo() {\n        return this.wire.sendAction('get-external-application-info', this.identity).then(({ payload }) => payload.data);\n    }\n}\nexports.ExternalApplication = ExternalApplication;\n\n\n//# sourceURL=webpack:///./src/api/external-application/external-application.ts?");

/***/ }),

/***/ "./src/api/fin.ts":
/*!************************!*\
  !*** ./src/api/fin.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst system_1 = __webpack_require__(/*! ./system/system */ \"./src/api/system/system.ts\");\nconst window_1 = __webpack_require__(/*! ./window/window */ \"./src/api/window/window.ts\");\nconst application_1 = __webpack_require__(/*! ./application/application */ \"./src/api/application/application.ts\");\nconst interappbus_1 = __webpack_require__(/*! ./interappbus/interappbus */ \"./src/api/interappbus/interappbus.ts\");\nconst notification_1 = __webpack_require__(/*! ./notification/notification */ \"./src/api/notification/notification.ts\");\nconst clipboard_1 = __webpack_require__(/*! ./clipboard/clipboard */ \"./src/api/clipboard/clipboard.ts\");\nconst external_application_1 = __webpack_require__(/*! ./external-application/external-application */ \"./src/api/external-application/external-application.ts\");\nconst frame_1 = __webpack_require__(/*! ./frame/frame */ \"./src/api/frame/frame.ts\");\nconst global_hotkey_1 = __webpack_require__(/*! ./global-hotkey */ \"./src/api/global-hotkey/index.ts\");\nclass Fin extends events_1.EventEmitter {\n    get me() {\n        return this.wire.me;\n    }\n    constructor(wire) {\n        super();\n        this.wire = wire;\n        this.System = new system_1.default(wire);\n        this.Window = new window_1.default(wire);\n        this.Application = new application_1.default(wire);\n        this.InterApplicationBus = new interappbus_1.default(wire);\n        this.Notification = new notification_1.default(wire);\n        this.Clipboard = new clipboard_1.default(wire);\n        this.ExternalApplication = new external_application_1.default(wire);\n        this.Frame = new frame_1.default(wire);\n        this.GlobalHotkey = new global_hotkey_1.default(wire);\n        //Handle disconnect events\n        wire.on('disconnected', () => {\n            this.emit('disconnected');\n        });\n    }\n}\nexports.default = Fin;\n\n\n//# sourceURL=webpack:///./src/api/fin.ts?");

/***/ }),

/***/ "./src/api/frame/frame.ts":
/*!********************************!*\
  !*** ./src/api/frame/frame.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\n/**\n * @lends Frame\n */\n// tslint:disable-next-line\nclass _FrameModule extends base_1.Base {\n    /**\n     * Asynchronously returns a reference to the specified frame. The frame does not have to exist\n     * @param {Identity} identity - the identity of the frame you want to wrap\n     * @return {Promise.<_Frame>}\n     * @tutorial Frame.wrap\n     * @static\n     */\n    wrap(identity) {\n        return Promise.resolve(new _Frame(this.wire, identity));\n    }\n    /**\n     * Synchronously returns a reference to the specified frame. The frame does not have to exist\n     * @param {Identity} identity - the identity of the frame you want to wrap\n     * @return {_Frame}\n     * @tutorial Frame.wrapSync\n     * @static\n     */\n    wrapSync(identity) {\n        return new _Frame(this.wire, identity);\n    }\n    /**\n     * Asynchronously returns a reference to the current frame\n     * @return {Promise.<_Frame>}\n     * @tutorial Frame.getCurrent\n     * @static\n     */\n    getCurrent() {\n        return Promise.resolve(new _Frame(this.wire, this.me));\n    }\n    /**\n     * Synchronously returns a reference to the current frame\n     * @return {_Frame}\n     * @tutorial Frame.getCurrentSync\n     * @static\n     */\n    getCurrentSync() {\n        return new _Frame(this.wire, this.me);\n    }\n}\nexports.default = _FrameModule;\n/**\n * @classdesc Represents a way to interact with `iframes`. Facilitates discovery of current context\n * (iframe or main window) as well as the ability to listen for frame-specific events.\n * @class\n * @alias Frame\n */\n// tslint:disable-next-line\nclass _Frame extends base_1.EmitterBase {\n    constructor(wire, identity) {\n        super(wire, ['frame', identity.uuid, identity.name]);\n        this.identity = identity;\n    }\n    /**\n     * Returns a frame info object for the represented frame\n     * @return {Promise.<FrameInfo>}\n     * @tutorial Frame.getInfo\n     */\n    getInfo() {\n        return this.wire.sendAction('get-frame-info', this.identity).then(({ payload }) => payload.data);\n    }\n    /**\n     * Returns a frame info object representing the window that the referenced iframe is\n     * currently embedded in\n     * @return {Promise.<FrameInfo>}\n     * @tutorial Frame.getParentWindow\n     */\n    getParentWindow() {\n        return this.wire.sendAction('get-parent-window', this.identity).then(({ payload }) => payload.data);\n    }\n}\nexports._Frame = _Frame;\n\n\n//# sourceURL=webpack:///./src/api/frame/frame.ts?");

/***/ }),

/***/ "./src/api/global-hotkey/index.ts":
/*!****************************************!*\
  !*** ./src/api/global-hotkey/index.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\n/**\n * The GlobalHotkey module can register/unregister a global hotkeys.\n * @namespace\n */\nclass GlobalHotkey extends base_1.EmitterBase {\n    constructor(wire) {\n        super(wire, ['global-hotkey']);\n        this.topic = 'global-hotkey';\n    }\n    /**\n     * Registers a global hotkey with the operating system.\n     * @return {Promise.<void>}\n     * @tutorial GlobalHotkey.register\n     */\n    async register(hotkey, listener) {\n        await this.on(hotkey, listener);\n        await this.wire.sendAction(\"global-hotkey-register\" /* REGISTER */, { hotkey });\n        return void 0;\n    }\n    /**\n     * Unregisters a global hotkey with the operating system.\n     * @return {Promise.<void>}\n     * @tutorial GlobalHotkey.unregister\n     */\n    async unregister(hotkey) {\n        await this.removeAllListeners(hotkey);\n        await this.wire.sendAction(\"global-hotkey-unregister\" /* UNREGISTER */, { hotkey });\n        return void 0;\n    }\n    /**\n     * Unregisters all global hotkeys for the current application.\n     * @return {Promise.<void>}\n     * @tutorial GlobalHotkey.unregisterAll\n     */\n    async unregisterAll() {\n        await Promise.all(this.eventNames()\n            .filter((name) => !(name === \"registered\" /* REGISTERED */ || name === \"unregistered\" /* UNREGISTERED */))\n            .map((name) => this.removeAllListeners(name)));\n        await this.wire.sendAction(\"global-hotkey-unregister-all\" /* UNREGISTER_ALL */, {});\n        return void 0;\n    }\n    /**\n     * Checks if a given hotkey has been registered\n     * @return {Promise.<bookean>}\n     * @tutorial GlobalHotkey.isRegistered\n     */\n    async isRegistered(hotkey) {\n        const { payload: { data } } = await this.wire.sendAction(\"global-hotkey-is-registered\" /* IS_REGISTERED */, { hotkey });\n        return data;\n    }\n}\nexports.default = GlobalHotkey;\n\n\n//# sourceURL=webpack:///./src/api/global-hotkey/index.ts?");

/***/ }),

/***/ "./src/api/interappbus/channel/channel.ts":
/*!************************************************!*\
  !*** ./src/api/interappbus/channel/channel.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst idOrResult = (func) => (...args) => {\n    const res = func(...args);\n    return res === undefined ? args[1] : res;\n};\nclass ChannelBase {\n    constructor(providerIdentity, send) {\n        this.defaultSet = false;\n        this.providerIdentity = providerIdentity;\n        this.subscriptions = new Map();\n        this.defaultAction = () => {\n            throw new Error('No action registered');\n        };\n        this.sendRaw = send;\n        this.send = async (to, action, payload) => {\n            const raw = await send('send-channel-message', Object.assign({}, to, { providerIdentity: this.providerIdentity, action, payload }))\n                .catch(reason => {\n                throw new Error(reason.message);\n            });\n            return raw.payload.data.result;\n        };\n    }\n    async processAction(action, payload, senderIdentity) {\n        try {\n            const mainAction = this.subscriptions.has(action)\n                ? this.subscriptions.get(action)\n                : (payload, id) => this.defaultAction(action, payload, id);\n            const preActionProcessed = this.preAction ? await this.preAction(action, payload, senderIdentity) : payload;\n            const actionProcessed = await mainAction(preActionProcessed, senderIdentity);\n            return this.postAction\n                ? await this.postAction(action, actionProcessed, senderIdentity)\n                : actionProcessed;\n        }\n        catch (e) {\n            if (this.errorMiddleware) {\n                return this.errorMiddleware(action, e, senderIdentity);\n            }\n            throw e;\n        }\n    }\n    beforeAction(func) {\n        if (this.preAction) {\n            throw new Error('Already registered beforeAction middleware');\n        }\n        this.preAction = idOrResult(func);\n    }\n    onError(func) {\n        if (this.errorMiddleware) {\n            throw new Error('Already registered error middleware');\n        }\n        this.errorMiddleware = func;\n    }\n    afterAction(func) {\n        if (this.postAction) {\n            throw new Error('Already registered afterAction middleware');\n        }\n        this.postAction = idOrResult(func);\n    }\n    remove(action) {\n        this.subscriptions.delete(action);\n    }\n    setDefaultAction(func) {\n        if (this.defaultSet) {\n            throw new Error('default action can only be set once');\n        }\n        else {\n            this.defaultAction = func;\n            this.defaultSet = true;\n        }\n    }\n    register(topic, listener) {\n        if (this.subscriptions.has(topic)) {\n            throw new Error(`Subscription already registered for action: ${topic}. Unsubscribe before adding new subscription`);\n        }\n        else {\n            this.subscriptions.set(topic, listener);\n            return true;\n        }\n    }\n}\nexports.ChannelBase = ChannelBase;\n\n\n//# sourceURL=webpack:///./src/api/interappbus/channel/channel.ts?");

/***/ }),

/***/ "./src/api/interappbus/channel/client.ts":
/*!***********************************************!*\
  !*** ./src/api/interappbus/channel/client.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst channel_1 = __webpack_require__(/*! ./channel */ \"./src/api/interappbus/channel/channel.ts\");\nclass ChannelClient extends channel_1.ChannelBase {\n    constructor(providerIdentity, send) {\n        super(providerIdentity, send);\n        this.disconnectListener = () => undefined;\n    }\n    async dispatch(action, payload) {\n        return this.send(this.providerIdentity, action, payload);\n    }\n    onDisconnection(listener) {\n        this.disconnectListener = listener;\n    }\n    async disconnect() {\n        const { channelName } = this.providerIdentity;\n        await this.sendRaw('disconnect-from-channel', { channelName });\n        const { channelId } = this.providerIdentity;\n        this.removeChannel(channelId);\n    }\n}\nexports.ChannelClient = ChannelClient;\n\n\n//# sourceURL=webpack:///./src/api/interappbus/channel/client.ts?");

/***/ }),

/***/ "./src/api/interappbus/channel/index.ts":
/*!**********************************************!*\
  !*** ./src/api/interappbus/channel/index.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst client_1 = __webpack_require__(/*! ./client */ \"./src/api/interappbus/channel/client.ts\");\nconst provider_1 = __webpack_require__(/*! ./provider */ \"./src/api/interappbus/channel/provider.ts\");\nconst base_1 = __webpack_require__(/*! ../../base */ \"./src/api/base.ts\");\nclass Channel extends base_1.EmitterBase {\n    constructor(wire) {\n        super(wire, ['channel']);\n        this.onmessage = (msg) => {\n            if (msg.action === 'process-channel-message') {\n                this.processChannelMessage(msg);\n                return true;\n            }\n            else if (msg.action === 'process-channel-connection') {\n                this.processChannelConnection(msg);\n                return true;\n            }\n            return false;\n        };\n        this.topic = 'channel';\n        this.channelMap = new Map();\n        wire.registerMessageHandler(this.onmessage.bind(this));\n    }\n    async getAllChannels() {\n        return this.wire.sendAction('get-all-channels')\n            .then(({ payload }) => payload.data);\n    }\n    async onChannelConnect(listener) {\n        await this.on('connected', listener);\n    }\n    async onChannelDisconnect(listener) {\n        await this.on('disconnected', listener);\n    }\n    async connect(channelName, options) {\n        if (!channelName || typeof channelName !== 'string') {\n            throw new Error('Please provide a channelName string to connect to a channel.');\n        }\n        const opts = options || {};\n        let resolver;\n        let listener;\n        const waitResponse = new Promise(resolve => {\n            resolver = resolve;\n            listener = (payload) => {\n                if (channelName === payload.channelName) {\n                    this.removeListener('connected', listener);\n                    this.connect(channelName, opts).then(response => {\n                        resolve(response);\n                    });\n                }\n            };\n            this.on('connected', listener);\n        });\n        try {\n            const { payload: { data: providerIdentity } } = await this.wire.sendAction('connect-to-channel', Object.assign({ channelName }, opts));\n            // If there isn't a matching channel, the above sendAction call will error out and go to catch, skipping the logic below\n            if (resolver) {\n                resolver();\n            }\n            this.removeListener('connected', listener);\n            const channel = new client_1.ChannelClient(providerIdentity, this.wire.sendAction.bind(this.wire));\n            const key = providerIdentity.channelId;\n            this.channelMap.set(key, channel);\n            //@ts-ignore use of protected property\n            channel.removeChannel = this.removeChannelFromMap.bind(this);\n            this.on('disconnected', (eventPayload) => {\n                if (eventPayload.channelName === channelName) {\n                    this.removeChannelFromMap(key);\n                    //@ts-ignore use of private property\n                    channel.disconnectListener(eventPayload);\n                }\n            });\n            return channel;\n        }\n        catch (e) {\n            const shouldWait = Object.assign({ wait: true }, opts).wait;\n            const internalNackMessage = 'internal-nack';\n            if (shouldWait && e.message && e.message.includes(internalNackMessage)) {\n                console.warn(`Channel not found for channelName: ${channelName}, waiting for channel creation.`);\n                return await waitResponse;\n            }\n            else if (e.message === internalNackMessage) {\n                throw new Error(`No channel found for channelName: ${channelName}`);\n            }\n            else {\n                throw new Error(e);\n            }\n        }\n    }\n    async create(channelName) {\n        if (!channelName) {\n            throw new Error('Please provide a channelName to create a channel');\n        }\n        const { payload: { data: providerIdentity } } = await this.wire.sendAction('create-channel', { channelName });\n        const channel = new provider_1.ChannelProvider(providerIdentity, this.wire.sendAction.bind(this.wire));\n        const key = providerIdentity.channelId;\n        this.channelMap.set(key, channel);\n        //@ts-ignore use of protected property\n        channel.removeChannel = this.removeChannelFromMap.bind(this);\n        this.on('client-disconnected', (eventPayload) => {\n            if (eventPayload.channelName === channelName) {\n                channel.connections = channel.connections.filter(identity => {\n                    return identity.uuid !== eventPayload.uuid || identity.name !== eventPayload.name;\n                });\n                //@ts-ignore use of private property\n                channel.disconnectListener(eventPayload);\n            }\n        });\n        return channel;\n    }\n    removeChannelFromMap(mapKey) {\n        this.channelMap.delete(mapKey);\n    }\n    async processChannelMessage(msg) {\n        const { senderIdentity, providerIdentity, action, ackToSender, payload } = msg.payload;\n        const key = providerIdentity.channelId;\n        const bus = this.channelMap.get(key);\n        if (!bus) {\n            ackToSender.payload.success = false;\n            ackToSender.payload.reason = `Client connection with identity ${JSON.stringify(this.wire.me)} no longer connected.`;\n            return this.wire.sendRaw(ackToSender);\n        }\n        try {\n            const res = await bus.processAction(action, payload, senderIdentity);\n            ackToSender.payload.payload = ackToSender.payload.payload || {};\n            ackToSender.payload.payload.result = res;\n            this.wire.sendRaw(ackToSender);\n        }\n        catch (e) {\n            ackToSender.payload.success = false;\n            ackToSender.payload.reason = e.message;\n            this.wire.sendRaw(ackToSender);\n        }\n    }\n    async processChannelConnection(msg) {\n        const { clientIdentity, providerIdentity, ackToSender, payload } = msg.payload;\n        const key = providerIdentity.channelId;\n        const bus = this.channelMap.get(key);\n        if (!bus) {\n            ackToSender.payload.success = false;\n            ackToSender.payload.reason = `Channel \"${providerIdentity.channelName}\" has been destroyed.`;\n            return this.wire.sendRaw(ackToSender);\n        }\n        try {\n            if (!(bus instanceof provider_1.ChannelProvider)) {\n                throw Error('Cannot connect to a channel client');\n            }\n            const res = await bus.processConnection(clientIdentity, payload);\n            ackToSender.payload.payload = ackToSender.payload.payload || {};\n            ackToSender.payload.payload.result = res;\n            this.wire.sendRaw(ackToSender);\n        }\n        catch (e) {\n            ackToSender.payload.success = false;\n            ackToSender.payload.reason = e.message;\n            this.wire.sendRaw(ackToSender);\n        }\n    }\n}\nexports.Channel = Channel;\n\n\n//# sourceURL=webpack:///./src/api/interappbus/channel/index.ts?");

/***/ }),

/***/ "./src/api/interappbus/channel/provider.ts":
/*!*************************************************!*\
  !*** ./src/api/interappbus/channel/provider.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst channel_1 = __webpack_require__(/*! ./channel */ \"./src/api/interappbus/channel/channel.ts\");\nclass ChannelProvider extends channel_1.ChannelBase {\n    constructor(providerIdentity, send) {\n        super(providerIdentity, send);\n        this.connectListener = () => undefined;\n        this.disconnectListener = () => undefined;\n        this.connections = [];\n    }\n    dispatch(to, action, payload) {\n        return this.send(to, action, payload);\n    }\n    async processConnection(senderId, payload) {\n        this.connections.push(senderId);\n        return this.connectListener(senderId, payload);\n    }\n    publish(action, payload) {\n        return this.connections.map(to => this.send(to, action, payload));\n    }\n    onConnection(listener) {\n        this.connectListener = listener;\n    }\n    onDisconnection(listener) {\n        this.disconnectListener = listener;\n    }\n    async destroy() {\n        const { channelName } = this.providerIdentity;\n        await this.sendRaw('destroy-channel', { channelName });\n        const { channelId } = this.providerIdentity;\n        this.removeChannel(channelId);\n    }\n}\nexports.ChannelProvider = ChannelProvider;\n\n\n//# sourceURL=webpack:///./src/api/interappbus/channel/provider.ts?");

/***/ }),

/***/ "./src/api/interappbus/interappbus.ts":
/*!********************************************!*\
  !*** ./src/api/interappbus/interappbus.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\nconst ref_counter_1 = __webpack_require__(/*! ../../util/ref-counter */ \"./src/util/ref-counter.ts\");\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst index_1 = __webpack_require__(/*! ./channel/index */ \"./src/api/interappbus/channel/index.ts\");\n/**\n * A messaging bus that allows for pub/sub messaging between different applications.\n * @namespace\n*/\nclass InterApplicationBus extends base_1.Base {\n    constructor(wire) {\n        super(wire);\n        this.events = {\n            subscriberAdded: 'subscriber-added',\n            subscriberRemoved: 'subscriber-removed'\n        };\n        this.refCounter = new ref_counter_1.default();\n        //tslint:disable-next-line\n        this.Channel = new index_1.Channel(wire);\n        this.emitter = new events_1.EventEmitter();\n        wire.registerMessageHandler(this.onmessage.bind(this));\n        this.on = this.emitter.on.bind(this.emitter);\n        this.removeAllListeners = this.emitter.removeAllListeners.bind(this.emitter);\n    }\n    /**\n     * Publishes a message to all applications running on OpenFin Runtime that\n     * are subscribed to the specified topic.\n     * @param { string } topic The topic on which the message is sent\n     * @param { any } message The message to be published. Can be either a primitive\n     * data type (string, number, or boolean) or composite data type (object, array)\n     * that is composed of other primitive or composite data types\n     * @return {Promise.<void>}\n     * @tutorial InterApplicationBus.publish\n    */\n    publish(topic, message) {\n        return this.wire.sendAction('publish-message', {\n            topic,\n            message,\n            sourceWindowName: this.me.name\n        }).then(() => undefined);\n    }\n    /**\n     * Sends a message to a specific application on a specific topic.\n     * @param { object } destination The uuid of the application to which the message is sent\n     * @param { string } topic The topic on which the message is sent\n     * @param { any } message The message to be sent. Can be either a primitive data\n     * type (string, number, or boolean) or composite data type (object, array) that\n     * is composed of other primitive or composite data types\n     * @return {Promise.<void>}\n     * @tutorial InterApplicationBus.send\n    */\n    send(destination, topic, message) {\n        return this.wire.sendAction('send-message', {\n            destinationUuid: destination.uuid,\n            destinationWindowName: destination.name,\n            topic,\n            message,\n            sourceWindowName: this.me.name\n        }).then(() => undefined);\n    }\n    /**\n     * Subscribes to messages from the specified application on the specified topic.\n     * If the subscription is for a uuid, [name], topic combination that has already\n     * been published to upon subscription you will receive the last 20 missed messages\n     * in the order they were published.\n     * @param { Identity } source This object is described in the Identity in the typedef\n     * @param { string } topic The topic on which the message is sent\n     * @param { function } listener A function that is called when a message has\n     * been received. It is passed the message, uuid and name of the sending application.\n     * The message can be either a primitive data type (string, number, or boolean) or\n     * composite data type (object, array) that is composed of other primitive or composite\n     * data types\n     * @return {Promise.<void>}\n     * @tutorial InterApplicationBus.subcribe\n     */\n    subscribe(source, topic, listener) {\n        const subKey = this.createSubscriptionKey(source.uuid, source.name || '*', topic);\n        const sendSubscription = () => {\n            return this.wire.sendAction('subscribe', {\n                sourceUuid: source.uuid,\n                sourceWindowName: source.name || '*',\n                topic,\n                destinationWindowName: this.me.name\n            });\n        };\n        const alreadySubscribed = () => {\n            // tslint:disable-next-line\n            return new Promise(r => r).then(() => undefined);\n        };\n        this.emitter.on(subKey, listener);\n        return this.refCounter.actOnFirst(subKey, sendSubscription, alreadySubscribed);\n    }\n    /**\n     * Unsubscribes to messages from the specified application on the specified topic.\n     * @param { Identity } source This object is described in the Identity in the typedef\n     * @param { string } topic The topic on which the message is sent\n     * @param { function } listener A callback previously registered with subscribe()\n     * @return {Promise.<void>}\n     * @tutorial InterApplicationBus.unsubscribe\n     */\n    unsubscribe(source, topic, listener) {\n        const subKey = this.createSubscriptionKey(source.uuid, source.name || '*', topic);\n        const sendUnsubscription = () => {\n            return this.wire.sendAction('unsubscribe', {\n                sourceUuid: source.uuid,\n                sourceWindowName: source.name || '*',\n                topic,\n                destinationWindowName: this.me.name\n            });\n        };\n        const dontSendUnsubscription = () => {\n            // tslint:disable-next-line\n            return new Promise(r => r).then(() => undefined);\n        };\n        this.emitter.removeListener(subKey, listener);\n        return this.refCounter.actOnLast(subKey, sendUnsubscription, dontSendUnsubscription);\n    }\n    processMessage(message) {\n        const { payload: { message: payloadMessage, sourceWindowName, sourceUuid, topic } } = message;\n        const keys = [\n            this.createSubscriptionKey(sourceUuid, sourceWindowName, topic),\n            this.createSubscriptionKey(sourceUuid, '*', topic),\n            this.createSubscriptionKey('*', '*', topic)\n        ];\n        const idOfSender = { uuid: sourceUuid, name: sourceWindowName };\n        keys.forEach((key) => {\n            this.emitter.emit(key, payloadMessage, idOfSender);\n        });\n    }\n    emitSubscriverEvent(type, message) {\n        const { payload: { name, uuid, topic } } = message;\n        const payload = { name, uuid, topic };\n        this.emitter.emit(type, payload);\n    }\n    createSubscriptionKey(uuid, name, topic) {\n        const n = name || '*';\n        if (!(uuid && n && topic)) {\n            throw new Error('Missing uuid, name, or topic string');\n        }\n        return createKey(uuid, n, topic);\n    }\n    onmessage(message) {\n        const { action } = message;\n        switch (action) {\n            case 'process-message':\n                this.processMessage(message);\n                break;\n            case this.events.subscriberAdded:\n                this.emitSubscriverEvent(this.events.subscriberAdded, message);\n                break;\n            case this.events.subscriberRemoved:\n                this.emitSubscriverEvent(this.events.subscriberRemoved, message);\n                break;\n            default: break;\n        }\n        return true;\n    }\n}\nexports.default = InterApplicationBus;\nclass InterAppPayload {\n}\nexports.InterAppPayload = InterAppPayload;\nfunction createKey(...toHash) {\n    return toHash.map((item) => {\n        return (new Buffer('' + item)).toString('base64');\n    }).join('/');\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./src/api/interappbus/interappbus.ts?");

/***/ }),

/***/ "./src/api/notification/notification.ts":
/*!**********************************************!*\
  !*** ./src/api/notification/notification.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\nconst events = {\n    show: 'show',\n    close: 'close',\n    error: 'error',\n    click: 'click',\n    message: 'message'\n};\nclass NotificationOptions {\n    // tslint:disable-next-line\n    constructor(options = {}, identity, notificationId) {\n        const { url, message, timeout, ignoreMouseOver } = options;\n        this.url = url;\n        this.message = message || null;\n        this.timeout = timeout;\n        this.notificationId = notificationId;\n        this.uuidOfProxiedApp = identity.uuid;\n        this.ignoreMouseOver = ignoreMouseOver;\n    }\n}\nexports.NotificationOptions = NotificationOptions;\n/**\n * @classdesc A Notification object represents a window on OpenFin Runtime which\n * is shown briefly to the user on the bottom-right corner of the primary monitor.\n * A notification is typically used to alert the user of some important event which\n * requires his or her attention. Notifications are a child or your application that\n * are controlled by the runtime.\n * @class\n * @alias Notification\n */\n// tslint:disable-next-line\nclass _Notification extends base_1.EmitterBase {\n    constructor(wire, options) {\n        super(wire, ['notification', '' + options.notificationId]);\n        this.listenerList = ['newListener'];\n        this.unhookAllListeners = () => {\n            this.listenerList.forEach(event => {\n                this.removeAllListeners(event);\n            });\n            this.listenerList.length = 0;\n        };\n        this.options = options;\n        this.url = options.url;\n        this.timeout = options.timeout;\n        this.message = options.message;\n        this.notificationId = options.notificationId;\n        this.on('newListener', (event) => {\n            this.listenerList.push(event);\n        });\n        // give any user added listeners a chance to run then unhook\n        this.on('close', () => {\n            setTimeout(this.unhookAllListeners, 1);\n        });\n    }\n    /**\n     * Invoked when the notification is shown\n     * @return {Promise.<void>}\n     * @tutorial Notification.show\n     */\n    async show() {\n        if (!this.url) {\n            throw new Error('Notifications require a url');\n        }\n        await this.wire.sendAction('send-action-to-notifications-center', {\n            action: 'create-notification',\n            payload: {\n                url: this.url,\n                notificationId: this.options.notificationId,\n                message: {\n                    message: this.message\n                },\n                timeout: this.timeout\n            }\n        });\n    }\n    /**\n     * Sends a message to the notification.\n     * @param { any } message The message to be sent to the notification.\n     * Can be either a primitive data type (string, number, or boolean)\n     * or composite data type (object, array) that is composed of other\n     * primitive or composite data types\n     * @return {Promise.<void>}\n     * @tutorial Notification.sendMessage\n     */\n    async sendMessage(message) {\n        await this.wire.sendAction('send-action-to-notifications-center', {\n            action: 'send-notification-message',\n            payload: {\n                notificationId: this.options.notificationId,\n                message: {\n                    message\n                }\n            }\n        });\n    }\n    /**\n     * Closes the notification\n     * @return {Promise.<void>}\n     * @tutorial Notification.close\n     */\n    async close() {\n        await this.wire.sendAction('send-action-to-notifications-center', {\n            action: 'close-notification',\n            payload: {\n                notificationId: this.options.notificationId\n            }\n        });\n    }\n}\nexports._Notification = _Notification;\n// tslint:disable-next-line\nclass _NotificationModule extends base_1.Base {\n    constructor() {\n        super(...arguments);\n        this.nextNoteId = 0;\n        this.events = events;\n    }\n    genNoteId() {\n        // tslint:disable-next-line\n        return ++this.nextNoteId;\n    }\n    ;\n    create(options) {\n        const noteOptions = new NotificationOptions(options, this.me, this.genNoteId());\n        return new _Notification(this.wire, noteOptions);\n    }\n    ;\n}\nexports.default = _NotificationModule;\n\n\n//# sourceURL=webpack:///./src/api/notification/notification.ts?");

/***/ }),

/***/ "./src/api/system/system.ts":
/*!**********************************!*\
  !*** ./src/api/system/system.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\nconst transport_errors_1 = __webpack_require__(/*! ../../transport/transport-errors */ \"./src/transport/transport-errors.ts\");\nconst window_1 = __webpack_require__(/*! ../window/window */ \"./src/api/window/window.ts\");\n/**\n * AppAssetInfo interface\n * @typedef { Object } AppAssetInfo\n * @property { string } src  The URL to a zip file containing the package files (executables, dlls, etc)\n * @property { string } alias The name of the asset\n * @property { string } version The version of the package\n * @property { string } target Specify default executable to launch. This option can be overridden in launchExternalProcess\n * @property { string } args The default command line arguments for the aforementioned target.\n * @property { boolean } mandatory When set to true, the app will fail to load if the asset cannot be downloaded.\n * When set to false, the app will continue to load if the asset cannot be downloaded. (Default: true)\n */\n/**\n * AppAssetRequest interface\n * @typedef { Object } AppAssetRequest\n * @property { string } alias The name of the asset\n */\n/**\n * ApplicationInfo interface\n * @typedef { Object } ApplicationInfo\n * @property { boolean } isRunning  true when the application is running\n * @property { string } uuid uuid of the application\n * @property { string } parentUuid uuid of the application that launches this application\n */\n/**\n * @typedef { Object } ClearCacheOption\n * @summary Clear cache options.\n * @desc These are the options required by the clearCache function.\n *\n * @property {boolean} appcache html5 application cache\n * @property {boolean} cache browser data cache for html files and images\n * @property {boolean} cookies browser cookies\n * @property {boolean} localStorage browser data that can be used across sessions\n */\n/**\n * CookieInfo interface\n * @typedef { Object } CookieInfo\n * @property { string } name  The name of the cookie\n * @property { string } domain The domain of the cookie\n * @property { string } path The path of the cookie\n */\n/**\n * CookieOption interface\n * @typedef { Object } CookieOption\n * @property { string } name The name of the cookie\n */\n/**\n * CpuInfo interface\n * @typedef { Object } CpuInfo\n * @property { string } model The model of the cpu\n * @property { number } speed The number in MHz\n * @property { Time } times The numbers of milliseconds the CPU has spent in different modes.\n */\n/**\n* CrashReporterOption interface\n* @typedef { Object } CrashReporterOption\n* @property { boolean } diagnosticMode In diagnostic mode the crash reporter will send diagnostic logs to\n*  the OpenFin reporting service on runtime shutdown\n* @property { boolean } isRunning check if it's running\n*/\n/**\n * DipRect interface\n * @typedef { Object } DipRect\n * @property { Rect } dipRect The DIP coordinates\n * @property { Rect } scaledRect The scale coordinates\n */\n/**\n * DipScaleRects interface\n * @typedef { Object } DipScaleRects\n * @property { Rect } dipRect The DIP coordinates\n * @property { Rect } scaledRect The scale coordinates\n */\n/**\n * DownloadPreloadInfo interface\n * @typedef { Object } DownloadPreloadInfo\n * @desc downloadPreloadScripts function return value\n * @property { string } url url to the preload script\n * @property { string } error error during preload script acquisition\n * @property { boolean } succeess download operation success\n */\n/**\n * DownloadPreloadOption interface\n * @typedef { Object } DownloadPreloadOption\n * @desc These are the options object required by the downloadPreloadScripts function\n * @property { string } url url to the preload script\n */\n/**\n * Entity interface\n * @typedef { Object } Entity\n * @property { string } type The type of the entity\n * @property { string } uuid The uuid of the entity\n */\n/**\n * EntityInfo interface\n * @typedef { Object } EntityInfo\n * @property { string } name The name of the entity\n * @property { string } uuid The uuid of the entity\n * @property { Identity } parent The parent of the entity\n * @property { string } entityType The type of the entity\n */\n/**\n * ExternalApplicationInfo interface\n * @typedef { Object } ExternalApplicationInfo\n * @property { Identity } parent The parent identity\n */\n/**\n * ExternalConnection interface\n * @typedef { Object } ExternalConnection\n * @property { string } token The token to broker an external connection\n * @property { string } uuid The uuid of the external connection\n */\n/**\n * ExternalProcessRequestType interface\n * @typedef { Object } ExternalProcessRequestType\n * @property { string } path The file path to where the running application resides\n * @property { string } arguments The argument passed to the running application\n * @property { Object } listener This is described in the {LaunchExternalProcessListner} type definition\n */\n/**\n * FrameInfo interface\n * @typedef { Object } FrameInfo\n * @property { string } name The name of the frame\n * @property { string } uuid The uuid of the frame\n * @property { entityType } entityType The entity type, could be 'window', 'iframe', 'external connection' or 'unknown'\n * @property { Identity } parent The parent identity\n */\n/**\n * GetLogRequestType interface\n * @typedef { Object } GetLogRequestType\n * @property { string } name The name of the running application\n * @property { number } endFile The file length of the log file\n * @property { number } sizeLimit The set size limit of the log file\n */\n/**\n * GpuInfo interface\n * @typedef { Object } GpuInfo\n * @property { string } name The graphics card name\n */\n/**\n * HostSpecs interface\n * @typedef { Object } HostSpecs\n * @property { boolean } aeroGlassEnabled Value to check if Aero Glass theme is supported on Windows platforms\n * @property { string } arch \"x86\" for 32-bit or \"x86_64\" for 64-bit\n * @property { Array<CpuInfo> } cpus The same payload as Node's os.cpus()\n * @property { GpuInfo } gpu The graphics card name\n * @property { number } memory The same payload as Node's os.totalmem()\n * @property { string } name The OS name and version/edition\n * @property { boolean } screenSaver Value to check if screensaver is running. Supported on Windows only\n */\n/**\n * Identity interface\n * @typedef { Object } Identity\n * @property { string } name The name of the application\n * @property { string } uuid The uuid of the application\n */\n/**\n * LogInfo interface\n * @typedef { Object } LogInfo\n * @property { string } name The filename of the log\n * @property { number } size The size of the log in bytes\n * @property { string } date The unix time at which the log was created \"Thu Jan 08 2015 14:40:30 GMT-0500 (Eastern Standard Time)\"\"\n */\n/**\n * MonitorDetails interface\n * @typedef { Object } MonitorDetails\n * @property { DipScaleRects } available The available DIP scale coordinates\n * @property { Rect } availableRect The available monitor coordinates\n * @property { string } deviceId The device id of the display\n * @property { boolean } displayDeviceActive true if the display is active\n * @property { number } deviceScaleFactor The device scale factor\n * @property { Rect } monitorRect The monitor coordinates\n * @property { string } name The name of the display\n * @property { Point } dpi The dots per inch\n * @property { DipScaleRects } monitor The monitor coordinates\n */\n/**\n * MonitorInfo interface\n * @typedef { Object } MonitorInfo\n * @property { number } deviceScaleFactor The device scale factor\n * @property { Point } dpi The dots per inch\n * @property { Array<MonitorDetails> } nonPrimaryMonitors The array of monitor details\n * @property { MonitorDetails } primaryMonitor The monitor details\n * @property { string } reason always \"api-query\"\n * @property { TaskBar } taskBar The taskbar on monitor\n * @property { DipRect } virtualScreen The virtual display screen coordinates\n */\n/**\n * @typedef { verbose | info | warning | error | fatal } LogLevel\n * @summary Log verbosity levels.\n * @desc Describes the minimum level (inclusive) above which logs will be written\n *\n * @property { string } verbose all logs written\n * @property { string } info info and above\n * @property { string } warning warning and above\n * @property { string } error error and above\n * @property { string } fatal fatal only, indicates a crash is imminent\n */\n/**\n * PointTopLeft interface\n * @typedef { Object } PointTopLeft\n * @property { number } top The mouse top position in virtual screen coordinates\n * @property { number } left The mouse left position in virtual screen coordinates\n */\n/**\n * Point interface\n * @typedef { Object } Point\n * @property { number } x The mouse x position\n * @property { number } y The mouse y position\n */\n/**\n * ProcessInfo interface\n * @typedef { Object } ProcessInfo\n * @property { numder } cpuUsage The percentage of total CPU usage\n * @property { string } name The application name\n * @property { number } nonPagedPoolUsage The current nonpaged pool usage in bytes\n * @property { number } pageFaultCount The number of page faults\n * @property { number } pagedPoolUsage The current paged pool usage in bytes\n * @property { number } pagefileUsage The total amount of memory in bytes that the memory manager has committed\n * @property { number } peakNonPagedPoolUsage The peak nonpaged pool usage in bytes\n * @property { number } peakPagedPoolUsage The peak paged pool usage in bytes\n * @property { number } peakPagefileUsage The peak value in bytes of pagefileUsage during the lifetime of this process\n * @property { number } peakWorkingSetSize The peak working set size in bytes\n * @property { number } processId The native process identifier\n * @property { string } uuid The application UUID\n * @property { nubmer } workingSetSize The current working set size (both shared and private data) in bytes\n */\n/**\n * ProxyConfig interface\n * @typedef { Object } ProxyConfig\n * @property { string } proxyAddress The configured proxy address\n * @property { numder } proxyPort The configured proxy port\n * @property { string } type The proxy Type\n */\n/**\n * ProxyInfo interface\n * @typedef { Object } ProxyInfo\n * @property { ProxyConfig } config The proxy config\n * @property { ProxySystemInfo } system The proxy system info\n */\n/**\n * ProxySystemInfo interface\n * @typedef { Object } ProxySystemInfo\n * @property { string } autoConfigUrl The auto configuration url\n * @property { string } bypass The proxy bypass info\n * @property { boolean } enabled Value to check if a proxy is enabled\n * @property { string } proxy The proxy info\n */\n/**\n * Rect interface\n * @typedef { Object } Rect\n * @property { number } bottom The bottom-most coordinate\n * @property { nubmer } left The left-most coordinate\n * @property { number } right The right-most coordinate\n * @property { nubmer } top The top-most coordinate\n */\n/**\n * RegistryInfo interface\n * @typedef { Object } RegistryInfo\n * @property { any } data The registry data\n * @property { string } rootKey The registry root key\n * @property { string } subkey The registry key\n * @property { string } type The registry type\n * @property { string } value The registry value name\n */\n/**\n * RuntimeDownloadOptions interface\n * @typedef { Object } RuntimeDownloadOptions\n * @desc These are the options object required by the downloadRuntime function.\n * @property { string } version The given version to download\n */\n/**\n * RuntimeInfo interface\n * @typedef { Object } RuntimeInfo\n * @property { string } architecture The runtime build architecture\n * @property { string } manifestUrl The runtime manifest URL\n * @property { nubmer } port The runtime websocket port\n * @property { string } securityRealm The runtime security realm\n * @property { string } version The runtime version\n */\n/**\n * RVMInfo interface\n * @typedef { Object } RVMInfo\n * @property { string } action The name of action: \"get-rvm-info\"\n * @property { string } appLogDirectory The app log directory\n * @property { string } path The path of OpenfinRVM.exe\n * @property { string } 'start-time' The start time of RVM\n * @property { string } version The version of RVM\n * @property { string } 'working-dir' The working directory\n */\n/**\n * ShortCutConfig interface\n * @typedef { Object } ShortCutConfig\n * @property { boolean } desktop true if application has a shortcut on the desktop\n * @property { boolean } startMenu true if application has shortcut in the start menu\n * @property { boolean } systemStartup true if application will be launched on system startup\n */\n/**\n * TaskBar interface\n * @typedef { Object } TaskBar\n * @property { string } edge which edge of a monitor the taskbar is on\n * @property { Rect } rect The taskbar coordinates\n */\n/**\n * TerminateExternalRequestType interface\n * @typedef { Object } TerminateExternalRequestType\n * @property { string } uuid The uuid of the running application\n * @property { number } timeout Time out period before the running application terminates\n * @property { boolean } killtree Value to terminate the running application\n */\n/**\n * Time interface\n * @typedef { Object } Time\n * @property { number } user The number of milliseconds the CPU has spent in user mode\n * @property { number } nice The number of milliseconds the CPU has spent in nice mode\n * @property { number } sys The number of milliseconds the CPU has spent in sys mode\n * @property { number } idle The number of milliseconds the CPU has spent in idle mode\n * @property { number } irq The number of milliseconds the CPU has spent in irq mode\n */\n/**\n * TrayInfo interface\n * @typedef { Object } TrayInfo\n * @property { Bounds } bounds The bound of tray icon in virtual screen pixels\n * @property { MonitorInfo } monitorInfo Please see fin.System.getMonitorInfo for more information\n * @property { number } x copy of bounds.x\n * @property { number } y copy of bounds.y\n */\n/**\n * WindowDetail interface\n * @typedef { Object } WindowDetail\n * @property { number } bottom The bottom-most coordinate of the window\n * @property { number } height The height of the window\n * @property { boolean } isShowing Value to check if the window is showing\n * @property { number } left The left-most coordinate of the window\n * @property { string } name The name of the window\n * @property { number } right The right-most coordinate of the window\n * @property { string } state The window state\n * @property { number } top The top-most coordinate of the window\n * @property { number } width The width of the window\n */\n/**\n * WindowInfo interface\n * @typedef { Object } WindowInfo\n * @property { Array<WindowDetail> } childWindows The array of child windows details\n * @property { WindowDetail } mainWindow The main window detail\n * @property { string } uuid The uuid of the application\n */\n/**\n * An object representing the core of OpenFin Runtime. Allows the developer\n * to perform system-level actions, such as accessing logs, viewing processes,\n * clearing the cache and exiting the runtime.\n * @namespace\n */\nclass System extends base_1.EmitterBase {\n    constructor(wire) {\n        super(wire, ['system']);\n    }\n    sendExternalProcessRequest(action, options) {\n        return new Promise((resolve, reject) => {\n            const exitEventKey = 'external-process-exited';\n            let processUuid;\n            let externalProcessExitHandler;\n            let ofWindow;\n            if (typeof options.listener === 'function') {\n                externalProcessExitHandler = (payload) => {\n                    const data = payload || {};\n                    const exitPayload = {\n                        topic: 'exited',\n                        uuid: data.processUuid || '',\n                        exitCode: data.exitCode || 0\n                    };\n                    if (processUuid === payload.processUuid) {\n                        options.listener(exitPayload);\n                        ofWindow.removeListener(exitEventKey, externalProcessExitHandler);\n                    }\n                };\n                // window constructor expects the name is not undefined\n                if (!this.wire.me.name) {\n                    this.wire.me.name = this.wire.me.uuid;\n                }\n                ofWindow = new window_1._Window(this.wire, this.wire.me);\n                ofWindow.on(exitEventKey, externalProcessExitHandler);\n            }\n            this.wire.sendAction(action, options)\n                .then(({ payload }) => {\n                processUuid = payload.data.uuid;\n                resolve(payload.data);\n            }).catch((err) => {\n                if (ofWindow) {\n                    ofWindow.removeListener(exitEventKey, externalProcessExitHandler);\n                }\n                reject(err);\n            });\n        });\n    }\n    /**\n     * Returns the version of the runtime. The version contains the major, minor,\n     * build and revision numbers.\n     * @return {Promise.<string>}\n     * @tutorial System.getVersion\n     */\n    getVersion() {\n        return this.wire.sendAction('get-version')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Clears cached data containing application resource\n     * files (images, HTML, JavaScript files), cookies, and items stored in the\n     * Local Storage.\n     * @param { ClearCacheOption } options - See tutorial for more details.\n     * @return {Promise.<void>}\n     * @tutorial System.clearCache\n     */\n    clearCache(options) {\n        return this.wire.sendAction('clear-cache', options).then(() => undefined);\n    }\n    /**\n     * Clears all cached data when OpenFin Runtime exits.\n     * @return {Promise.<void>}\n     * @tutorial System.deleteCacheOnExit\n     */\n    deleteCacheOnExit() {\n        return this.wire.sendAction('delete-cache-request').then(() => undefined);\n    }\n    /**\n     * Exits the Runtime.\n     * @return {Promise.<void>}\n     * @tutorial System.exit\n     */\n    exit() {\n        return this.wire.sendAction('exit-desktop').then(() => undefined);\n    }\n    /**\n     * Writes any unwritten cookies data to disk.\n     * @return {Promise.<void>}\n     * @tutorial System.flushCookieStore\n     */\n    flushCookieStore() {\n        return this.wire.sendAction('flush-cookie-store').then(() => undefined);\n    }\n    /**\n     * Retrieves an array of data (name, ids, bounds) for all application windows.\n     * @return {Promise.Array.<WindowInfo>}\n     * @tutorial System.getAllWindows\n     */\n    getAllWindows() {\n        return this.wire.sendAction('get-all-windows')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves an array of data for all applications.\n     * @return {Promise.Array.<ApplicationInfo>}\n     * @tutorial System.getAllApplications\n     */\n    getAllApplications() {\n        return this.wire.sendAction('get-all-applications')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves the command line argument string that started OpenFin Runtime.\n     * @return {Promise.<string>}\n     * @tutorial System.getCommandLineArguments\n     */\n    getCommandLineArguments() {\n        return this.wire.sendAction('get-command-line-arguments')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Get the current state of the crash reporter.\n     * @return {Promise.<CrashReporterOption>}\n     * @tutorial System.getCrashReporterState\n     */\n    getCrashReporterState() {\n        return this.wire.sendAction('get-crash-reporter-state').then(({ payload }) => payload.data);\n    }\n    /* <-- Note the one asterisk to hide from jsdoc because we don't want to publish this method anymore.\n     * @deprecated Use {@link System.getMachineId} instead.\n     */\n    getDeviceId() {\n        console.warn('Function is deprecated; use getMachineId instead.');\n        return this.wire.sendAction('get-device-id').then(({ payload }) => payload.data);\n    }\n    /**\n     * Start the crash reporter for the browser process if not already running.\n     * You can optionally specify `diagnosticMode` to have the logs sent to\n     * OpenFin on runtime close\n     *\n     * @param { CrashReporterOption } options - configure crash reporter\n     * @return {Promise.<CrashReporterOption>}\n     * @tutorial System.startCrashReporter\n     */\n    startCrashReporter(options) {\n        return new Promise((resolve, reject) => {\n            if (!options.diagnosticMode) {\n                return reject(new Error('diagnosticMode not found in options'));\n            }\n            this.wire.sendAction('start-crash-reporter', options).then(({ payload }) => resolve(payload.data)).catch(err => reject(err));\n        });\n    }\n    /**\n     * Returns a hex encoded hash of the mac address and the currently logged in user name\n     * @return {Promise.<string>}\n     * @tutorial System.getDeviceUserId\n     */\n    getDeviceUserId() {\n        return this.wire.sendAction('get-device-user-id').then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves a frame info object for the uuid and name passed in\n     * @param { string } uuid - The UUID of the target.\n     * @param { string } name - The name of the target.\n     * @return {Promise.<EntityInfo>}\n     * @tutorial System.getEntityInfo\n     */\n    getEntityInfo(uuid, name) {\n        return this.wire.sendAction('get-entity-info', { uuid, name }).then(({ payload }) => payload.data);\n    }\n    /**\n     * Gets the value of a given environment variable on the computer on which the runtime is installed\n     * @return {Promise.<string>}\n     * @tutorial System.getEnvironmentVariable\n     */\n    getEnvironmentVariable(envName) {\n        return this.wire.sendAction('get-environment-variable', {\n            environmentVariables: envName\n        })\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Get current focused window.\n     * @return {Promise.<WindowInfo>}\n     * @tutorial System.getFocusedWindow\n     */\n    getFocusedWindow() {\n        return this.wire.sendAction('get-focused-window').then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves the contents of the log with the specified filename.\n     * @param { GetLogRequestType } options A object that id defined by the GetLogRequestType interface\n     * @return {Promise.<string>}\n     * @tutorial System.getLog\n     */\n    getLog(options) {\n        return this.wire.sendAction('view-log', options)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Returns a unique identifier (UUID) provided by the machine.\n     * @return {Promise.<string>}\n     * @tutorial System.getMachineId\n     */\n    getMachineId() {\n        return this.wire.sendAction('get-machine-id').then(({ payload }) => payload.data);\n    }\n    /**\n     * Returns the minimum (inclusive) logging level that is currently being written to the log.\n     * @return {Promise.<LogLevel>}\n     * @tutorial System.getMinLogLevel\n     */\n    getMinLogLevel() {\n        return this.wire.sendAction('get-min-log-level').then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves an array containing information for each log file.\n     * @return {Promise.Array<LogInfo>}\n     * @tutorial System.getLogList\n     */\n    getLogList() {\n        return this.wire.sendAction('list-logs')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves an object that contains data about the monitor setup of the\n     * computer that the runtime is running on.\n     * @return {Promise.<MonitorInfo>}\n     * @tutorial System.getMonitorInfo\n     */\n    getMonitorInfo() {\n        return this.wire.sendAction('get-monitor-info')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Returns the mouse in virtual screen coordinates (left, top).\n     * @return {Promise.<PointTopLeft>}\n     * @tutorial System.getMousePosition\n     */\n    getMousePosition() {\n        return this.wire.sendAction('get-mouse-position')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves an array of all of the runtime processes that are currently\n     * running. Each element in the array is an object containing the uuid\n     * and the name of the application to which the process belongs.\n     * @return {Promise.Array.<ProcessInfo>}\n     * @tutorial System.getProcessList\n     */\n    getProcessList() {\n        return this.wire.sendAction('process-snapshot')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves the Proxy settings.\n     * @return {Promise.<ProxyInfo>}\n     * @tutorial System.getProxySettings\n     */\n    getProxySettings() {\n        return this.wire.sendAction('get-proxy-settings')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Returns information about the running Runtime in an object.\n     * @return {Promise.<RuntimeInfo>}\n     * @tutorial System.getRuntimeInfo\n     */\n    getRuntimeInfo() {\n        return this.wire.sendAction('get-runtime-info').then(({ payload }) => payload.data);\n    }\n    /**\n     * Returns information about the running RVM in an object.\n     * @return {Promise.<RVMInfo>}\n     * @tutorial System.getRvmInfo\n     */\n    // incompatible with standalone node process.\n    getRvmInfo() {\n        return this.wire.sendAction('get-rvm-info')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves system information.\n     * @return {Promise.<HostSpecs>}\n     * @tutorial System.getHostSpecs\n     */\n    getHostSpecs() {\n        return this.wire.sendAction('get-host-specs').then(({ payload }) => payload.data);\n    }\n    /**\n     * Runs an executable or batch file.\n     * @param { ExternalProcessRequestType } options A object that is defined in the ExternalProcessRequestType interface\n     * @return {Promise.<Identity>}\n     * @tutorial System.launchExternalProcess\n     */\n    launchExternalProcess(options) {\n        return this.sendExternalProcessRequest('launch-external-process', options);\n    }\n    /**\n     * Monitors a running process.\n     * @param { ExternalProcessInfo } options See tutorial for more details\n     * @return {Promise.<Identity>}\n     * @tutorial System.monitorExternalProcess\n     */\n    monitorExternalProcess(options) {\n        return this.sendExternalProcessRequest('monitor-external-process', options);\n    }\n    /**\n     * Writes the passed message into both the log file and the console.\n     * @param { string } level The log level for the entry. Can be either \"info\", \"warning\" or \"error\"\n     * @param { string } message The log message text\n     * @return {Promise.<void>}\n     * @tutorial System.log\n     */\n    log(level, message) {\n        return this.wire.sendAction('write-to-log', { level, message }).then(() => undefined);\n    }\n    /**\n     * Opens the passed URL in the default web browser.\n     * @param { string } url The URL to open\n     * @return {Promise.<void>}\n     * @tutorial System.openUrlWithBrowser\n     */\n    openUrlWithBrowser(url) {\n        return this.wire.sendAction('open-url-with-browser', { url }).then(() => undefined);\n    }\n    /**\n     * Removes the process entry for the passed UUID obtained from a prior call\n     * of fin.System.launchExternalProcess().\n     * @param { string } uuid The UUID for a process obtained from a prior call to fin.desktop.System.launchExternalProcess()\n     * @return {Promise.<void>}\n     * @tutorial System.releaseExternalProcess\n     */\n    releaseExternalProcess(uuid) {\n        return this.wire.sendAction('release-external-process', { uuid }).then(() => undefined);\n    }\n    /**\n     * Shows the Chromium Developer Tools for the specified window\n     * @param { Identity } identity This is a object that is defined by the Identity interface\n     * @return {Promise.<void>}\n     * @tutorial System.showDeveloperTools\n     */\n    showDeveloperTools(identity) {\n        return this.wire.sendAction('show-developer-tools', identity).then(() => undefined);\n    }\n    /**\n     * Attempt to close an external process. The process will be terminated if it\n     * has not closed after the elapsed timeout in milliseconds.\n     * @param { TerminateExternalRequestType } options A object defined in the TerminateExternalRequestType interface\n     * @return {Promise.<void>}\n     * @tutorial System.terminateExternalProcess\n     */\n    terminateExternalProcess(options) {\n        return this.wire.sendAction('terminate-external-process', options)\n            .then(() => undefined);\n    }\n    /**\n     * Update the OpenFin Runtime Proxy settings.\n     * @param { ProxyConfig } options A config object defined in the ProxyConfig interface\n     * @return {Promise.<void>}\n     * @tutorial System.updateProxySettings\n     */\n    updateProxySettings(options) {\n        return this.wire.sendAction('update-proxy', options).then(() => undefined);\n    }\n    /**\n     * Downloads the given application asset\n     * @param { AppAssetInfo } appAsset App asset object\n     * @return {Promise.<void>}\n     * @tutorial System.downloadAsset\n     */\n    // incompatible with standalone node process.\n    downloadAsset(appAsset, progressListener) {\n        return new Promise((resolve, reject) => {\n            //node.js environment not supported\n            if (this.wire.environment.constructor.name === 'NodeEnvironment') {\n                reject(new transport_errors_1.NotSupportedError('downloadAsset only supported in an OpenFin Render process'));\n                return;\n            }\n            const downloadId = this.wire.environment.getNextMessageId().toString();\n            const dlProgressKey = `asset-download-progress-${downloadId}`;\n            const dlErrorKey = `asset-download-error-${downloadId}`;\n            const dlCompleteKey = `asset-download-complete-${downloadId}`;\n            const dlProgress = (progress) => {\n                const p = {\n                    downloadedBytes: progress.downloadedBytes,\n                    totalBytes: progress.totalBytes\n                };\n                progressListener(p);\n            };\n            const cleanListeners = () => {\n                this.removeListener(dlProgressKey, dlProgress);\n            };\n            const dlError = (r, err) => {\n                const error = err ? err : r;\n                cleanListeners();\n                reject(new transport_errors_1.RuntimeError(error));\n            };\n            const dlComplete = () => {\n                cleanListeners();\n                resolve();\n            };\n            this.on(dlProgressKey, dlProgress);\n            this.once(dlErrorKey, dlError);\n            this.once(dlCompleteKey, dlComplete);\n            const downloadOptions = Object.assign(appAsset, { downloadId });\n            this.wire.sendAction('download-asset', downloadOptions).catch((err) => {\n                cleanListeners();\n                reject(err);\n            });\n        });\n    }\n    /**\n    * Downloads a version of the runtime.\n    * @param { RuntimeDownloadOptions } options - Download options.\n    * @param {Function} [progressListener] - called as the runtime is downloaded with progress information.\n    * @return {Promise.<void>}\n    * @tutorial System.downloadRuntime\n    */\n    downloadRuntime(options, progressListener) {\n        return new Promise((resolve, reject) => {\n            //node.js environment not supported\n            if (this.wire.environment.constructor.name === 'NodeEnvironment') {\n                reject(new transport_errors_1.NotSupportedError('downloadRuntime only supported in an OpenFin Render process'));\n                return;\n            }\n            const downloadId = this.wire.environment.getNextMessageId().toString();\n            const dlProgressKey = `runtime-download-progress-${downloadId}`;\n            const dlErrorKey = `runtime-download-error-${downloadId}`;\n            const dlCompleteKey = `runtime-download-complete-${downloadId}`;\n            const dlProgress = (progress) => {\n                const p = {\n                    downloadedBytes: progress.downloadedBytes,\n                    totalBytes: progress.totalBytes\n                };\n                progressListener(p);\n            };\n            const cleanListeners = () => {\n                this.removeListener(dlProgressKey, dlProgress);\n            };\n            const dlError = (r, err) => {\n                const error = err ? err : r;\n                cleanListeners();\n                reject(new transport_errors_1.RuntimeError(error));\n            };\n            const dlComplete = () => {\n                cleanListeners();\n                resolve();\n            };\n            this.on(dlProgressKey, dlProgress);\n            this.once(dlErrorKey, dlError);\n            this.once(dlCompleteKey, dlComplete);\n            const downloadOptions = Object.assign(options, { downloadId });\n            this.wire.sendAction('download-runtime', downloadOptions).catch((err) => {\n                cleanListeners();\n                reject(err);\n            });\n        });\n    }\n    /**\n    * Download preload scripts from given URLs\n    * @param {DownloadPreloadOption[]} scripts - URLs of preload scripts. See tutorial for more details.\n    * @return {Promise.Array<DownloadPreloadInfo>}\n    * @tutorial System.downloadPreloadScripts\n    */\n    downloadPreloadScripts(scripts) {\n        return this.wire.sendAction('download-preload-scripts', { scripts }).then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves an array of data (name, ids, bounds) for all application windows.\n     * @return {Promise.Array.<Identity>}\n     * @tutorial System.getAllExternalApplications\n     */\n    getAllExternalApplications() {\n        return this.wire.sendAction('get-all-external-applications')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves app asset information.\n     * @param { AppAssetRequest } options\n     * @return {Promise.<AppAssetInfo>}\n     * @tutorial System.getAppAssetInfo\n     */\n    getAppAssetInfo(options) {\n        return this.wire.sendAction('get-app-asset-info', options).then(({ payload }) => payload.data);\n    }\n    /**\n     * Get additional info of cookies.\n     * @param { CookieOption } options - See tutorial for more details.\n     * @return {Promise.Array.<CookieInfo>}\n     * @tutorial System.getCookies\n     */\n    getCookies(options) {\n        return this.wire.sendAction('get-cookies', options).then(({ payload }) => payload.data);\n    }\n    /**\n     * Set the minimum log level above which logs will be written to the OpenFin log\n     * @param { LogLevel } The minimum level (inclusive) above which all calls to log will be written\n     * @return {Promise.<void>}\n     * @tutorial System.setMinLogLevel\n     */\n    setMinLogLevel(level) {\n        return this.wire.sendAction('set-min-log-level', { level }).then(() => undefined);\n    }\n    /**\n     * Retrieves the UUID of the computer on which the runtime is installed\n     * @param { string } uuid The uuid of the running application\n     * @return {Promise.<Entity>}\n     * @tutorial System.resolveUuid\n     */\n    resolveUuid(uuid) {\n        return this.wire.sendAction('resolve-uuid', {\n            entityKey: uuid\n        }).then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves an array of data for all external applications\n     * @param { Identity } requestingIdentity This object is described in the Identity typedef\n     * @param { any } data Any data type to pass to the method\n     * @return {Promise.<any>}\n     * @ignore\n     */\n    executeOnRemote(requestingIdentity, data) {\n        data.requestingIdentity = requestingIdentity;\n        return this.wire.ferryAction(data);\n    }\n    /**\n     * Reads the specifed value from the registry.\n     * @param { string } rootKey - The registry root key.\n     * @param { string } subkey - The registry key.\n     * @param { string } value - The registry value name.\n     * @return {Promise.<RegistryInfo>}\n     * @tutorial System.readRegistryValue\n     */\n    readRegistryValue(rootKey, subkey, value) {\n        return this.wire.sendAction('read-registry-value', {\n            rootKey: rootKey,\n            subkey: subkey,\n            value: value\n        }).then(({ payload }) => payload.data);\n    }\n    /**\n     * This function call will register a unique id and produce a token.\n     * The token can be used to broker an external connection.\n     * @param { string } uuid - A UUID for the remote connection.\n     * @return {Promise.<ExternalConnection>}\n     * @tutorial System.registerExternalConnection\n     */\n    registerExternalConnection(uuid) {\n        return this.wire.sendAction('register-external-connection', { uuid }).then(({ payload }) => payload.data);\n    }\n}\nexports.default = System;\n\n\n//# sourceURL=webpack:///./src/api/system/system.ts?");

/***/ }),

/***/ "./src/api/window/window.ts":
/*!**********************************!*\
  !*** ./src/api/window/window.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\nconst application_1 = __webpack_require__(/*! ../application/application */ \"./src/api/application/application.ts\");\n/**\n * @lends Window\n */\n// tslint:disable-next-line\nclass _WindowModule extends base_1.Base {\n    /**\n     * Asynchronously returns a Window object that represents an existing window.\n     * @param { Identity } identity\n     * @return {Promise.<_Window>}\n     * @tutorial Window.wrap\n     * @static\n     */\n    async wrap(identity) {\n        return new _Window(this.wire, identity);\n    }\n    /**\n     * Synchronously returns a Window object that represents an existing window.\n     * @param { Identity } identity\n     * @return {_Window}\n     * @tutorial Window.wrapSync\n     * @static\n     */\n    wrapSync(identity) {\n        return new _Window(this.wire, identity);\n    }\n    /**\n     * Creates a new Window.\n     * @param { WindowOption } options - Window creation options\n     * @return {Promise.<_Window>}\n     * @tutorial Window.create\n     * @static\n     */\n    create(options) {\n        const win = new _Window(this.wire, { uuid: this.me.uuid, name: options.name });\n        return win.createWindow(options);\n    }\n    /**\n     * Asynchronously returns a Window object that represents the current window\n     * @return {Promise.<_Window>}\n     * @tutorial Window.getCurrent\n     * @static\n     */\n    getCurrent() {\n        return this.wrap(this.wire.me);\n    }\n    /**\n     * Synchronously returns a Window object that represents the current window\n     * @return {_Window}\n     * @tutorial Window.getCurrentSync\n     * @static\n     */\n    getCurrentSync() {\n        return this.wrapSync(this.wire.me);\n    }\n}\nexports.default = _WindowModule;\n/**\n * @typedef { Object } Area\n * @property { number } height Area's height\n * @property { number } width Area's width\n * @property { number } x X coordinate of area's starting point\n * @property { number } y Y coordinate of area's starting point\n */\n/**\n * @typedef {object} Transition\n * @property {Opacity} opacity - The Opacity transition\n * @property {Position} position - The Position transition\n * @property {Size} size - The Size transition\n*/\n/**\n * @typedef {object} TransitionOptions\n * @property {boolean} interrupt - This option interrupts the current animation. When false it pushes\nthis animation onto the end of the animation queue.\n * @property {boolean} relative - Treat 'opacity' as absolute or as a delta. Defaults to false.\n */\n/**\n * @typedef {object} Size\n * @property {number} duration - The total time in milliseconds this transition should take.\n * @property {boolean} relative - Treat 'opacity' as absolute or as a delta. Defaults to false.\n * @property {number} width - Optional if height is present. Defaults to the window's current width.\n * @property {number} height - Optional if width is present. Defaults to the window's current height.\n */\n/**\n * @typedef {object} Position\n * @property {number} duration - The total time in milliseconds this transition should take.\n * @property {boolean} relative - Treat 'opacity' as absolute or as a delta. Defaults to false.\n * @property {number} left - Defaults to the window's current left position in virtual screen coordinates.\n * @property {number} top - Defaults to the window's current top position in virtual screen coordinates.\n */\n/**\n * @typedef {object} Opacity\n * @property {number} duration - The total time in milliseconds this transition should take.\n * @property {boolean} relative - Treat 'opacity' as absolute or as a delta. Defaults to false.\n * @property {number} opacity - This value is clamped from 0.0 to 1.0.\n*/\n/**\n * Bounds is a interface that has the properties of height,\n * width, left, top which are all numbers\n * @typedef { Object } Bounds\n * @property { number } height Get the application height bound\n * @property { number } width Get the application width bound\n * @property { number } top Get the application top bound\n * @property { number } left Get the application left bound\n * @property { number } right Get the application right bound\n * @property { number } bottom Get the application bottom bound\n */\n/**\n * @classdesc A basic window that wraps a native HTML window. Provides more fine-grained\n * control over the window state such as the ability to minimize, maximize, restore, etc.\n * By default a window does not show upon instantiation; instead the window's show() method\n * must be invoked manually. The new window appears in the same process as the parent window.\n * @class\n * @alias Window\n*/\n// The window.Window name is taken\n// tslint:disable-next-line\nclass _Window extends base_1.EmitterBase {\n    /**\n     * Raised when a window within this application requires credentials from the user.\n     *\n     * @event Window#auth-requested\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     * @property {object} authInfo\n     * @property {string} authInfo.host - Host server.\n     * @property {boolean} authInfo.isProxy - Indicates if the request involves a proxy.\n     * @property {number} authInfo.port - Port number.\n     * @property {string} authInfo.realm - Authentication request realm.\n     * @property {string} authInfo.scheme - Authentication scheme.\n     */\n    /**\n     * Raised when a window loses focus.\n     *\n     * @event Window#blurred\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     */\n    /**\n     * Raised after changes in a window's size and/or position.\n     *\n     * @event Window#bounds-changed\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     * @property {number} changeType - Describes what kind of change occurred.\n     0 means a change in position.\n     1 means a change in size.\n     2 means a change in position and size.\n     * @property {string} deferred - Indicated whether pending changes have been applied.\n     * @property {number} height - New height of the window.\n     * @property {number} left - New left most coordinate of the window.\n     * @property {number} top - New top most coordinate of the window.\n     * @property {number} width - New width of the window.\n     */\n    /**\n     * Raised when a window has been prevented from closing. A window will be prevented from closing by default,\n     either through the API or by a user when close-requested has been subscribed to and the Window.close(force) flag is false.\n     *\n     * @event Window#close-requested\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     */\n    /**\n     * Raised when a window has closed.\n     *\n     * @event Window#closed\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     */\n    /**\n     * Raised when a window has crashed.\n     *\n     * @event Window#crashed\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     */\n    /**\n     * Raised when the user movement is disabled after all prevent user changes in window's size and/or position have completed.\n     *\n     * @event Window#disabled-movement-bounds-changed\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     * @property {number} changeType - Describes what kind of change occurred.\n     0 means a change in position.\n     1 means a change in size.\n     2 means a change in position and size.\n     * @property {string} deferred - Indicated whether pending changes have been applied.\n     * @property {number} height - New height of the window.\n     * @property {number} left - New left most coordinate of the window.\n     * @property {number} top - New top most coordinate of the window.\n     * @property {number} width - New width of the window.\n     */\n    /**\n     * Raised when the user movement is disabled during prevented user changes to a window's size and/or position.\n     *\n     * @event Window#disabled-movement-bounds-changing\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     * @property {number} changeType - Describes what kind of change occurred.\n     0 means a change in position.\n     1 means a change in size.\n     2 means a change in position and size.\n     * @property {string} deferred - Indicated whether pending changes have been applied.\n     * @property {number} height - New height of the window.\n     * @property {number} left - New left most coordinate of the window.\n     * @property {number} top - New top most coordinate of the window.\n     * @property {number} width - New width of the window.\n     */\n    /**\n     * Raised when the window has been embedded.\n     *\n     * @event Window#embedded\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     */\n    /**\n     * Raised when an external process has exited.\n     *\n     * @event Window#external-process-exited\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     * @property {string} processUuid - The process handle UUID.\n     * @property {number} exitCode - The process exit code\n     */\n    /**\n     * Raised when an external process has started.\n     *\n     * @event Window#external-process-started\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     * @property {string} processUuid - The process handle UUID.\n     */\n    /**\n     * Raised when a window's user movement becomes disabled.\n     *\n     * @event Window#user-movement-disabled\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     */\n    /**\n     * Raised when a window's user movement becomes enabled.\n     *\n     * @event Window#user-movement-enabled\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     */\n    /**\n     * Raised when a window joins/leaves a group and/or when the group a window is a member of changes.\n     *\n     * @event Window#group-changed\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     * @property {string} source - Which group array the window that the event listener was registered on is included in:\n     'source' The window is included in sourceGroup.\n     'target' The window is included in targetGroup.\n     'nothing' The window is not included in sourceGroup nor targetGroup.\n     * @property {string} reason - The reason this event was triggered.\n     'leave' A window has left the group due to a leave or merge with group.\n     'join' A window has joined the group.\n     'merge' Two groups have been merged together.\n     'disband' There are no other windows in the group.\n     * @property {string} name - Name of the window.\n     * @property {legacyWindowIdentity[]} sourceGroup - All the windows in the group the sourceWindow originated from.\n     * @property {string} sourceWindowAppUuid - UUID of the application the sourceWindow belongs to the\n     source window is the window in which (merge/join/leave)group(s) was called.\n     * @property {string} sourceWindowName - Name of the sourcewindow.\n     The source window is the window in which (merge/join/leave)group(s) was called.\n     * @property {legacyWindowIdentity[]} targetGroup - All the windows in the group the targetWindow orginated from.\n     * @property {string} targetWindowAppUuid - UUID of the application the targetWindow belongs to.\n     The target window is the window that was passed into (merge/join)group(s).\n     * @property {string} targetWindowName - Name of the targetWindow.\n     The target window is the window that was passed into (merge/join)group(s).\n     */\n    /**\n     * Raised when a window has been hidden.\n     *\n     * @event Window#hidden\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     * @property {string} reason - Action prompted the close The reasons are:\n     \"hide\"\n     \"hide-on-close\"\n    */\n    /**\n     * Raised when a window is initialized.\n     *\n     * @event Window#initialized\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     */\n    /**\n     * Raised when a window is maximized.\n     *\n     * @event Window#maximized\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     */\n    /**\n     * Raised when a window is minimized.\n     *\n     * @event Window#minimized\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     */\n    /**\n     * Raised when window navigation is rejected as per ContentNavigation whitelist/blacklist rules.\n     *\n     * @event Window#navigation-rejected\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     * @property {string} sourceName - source of navigation window name.\n     * @property {string} url - Blocked content url.\n     */\n    /**\n     * Raised when a window is out of memory.\n     *\n     * @event Window#out-of-memory\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     */\n    /**\n     * Raised after the execution of all of a window's preload scripts. Contains\n     information about all window's preload scripts' final states.\n     *\n     * @event Window#preload-scripts-state-changed\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     * @property {preloadScriptState[]} preloadState -  An array of all final preload scripts' states\n     */\n    /**\n     * Raised during the execution of a window's preload script. Contains information\n     about a single window's preload script's state, for which the event has been raised.\n     *\n     * @event Window#preload-scripts-state-changing\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     * @property {preloadScriptState[]} preloadState -  An array of all final preload scripts' states\n     */\n    /**\n     * Raised when an HTTP load was cancelled or failed.\n     *\n     * @event Window#resource-load-failed\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     * @property {number} errorCode - The Chromium error code.\n     * @property {string} errorDescription - The Chromium error description.\n     * @property {string} validatedURL - The url attempted.\n     * @property {boolean} isMainFrame - Was the attempt made from the main frame.\n     */\n    /**\n     * Raised when an HTTP resource request has received response details.\n     *\n     * @event Window#resource-response-received\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     * @property {boolean} status - Status of the request.\n     * @property {string} newUrl - The URL of the responded resource.\n     * @property {string} originalUrl - The requested URL.\n     * @property {number} httpResponseCode - The HTTP Response code.\n     * @property {string} requestMethod - The HTTP request method.\n     * @property {string} referrer - The HTTP referrer.\n     * @property {object} headers - The HTTP headers.\n     * @property {string} resourceType - Resource type:\n     \"mainFrame\", \"subFrame\",\n     \"styleSheet\", \"script\", \"image\",\n     \"object\", \"xhr\", or \"other\"\n    */\n    /**\n     * Raised when a window has reloaded.\n     *\n     * @event Window#reloaded\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     * @property {string} url - Url has has been reloaded.\n     */\n    /**\n     * Raised when a window is displayed after having been minimized or\n     when a window leaves the maximize state without minimizing.\n     *\n     * @event Window#restored\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     */\n    /**\n     * Raised when a window has been prevented from showing.\n     A window will be prevented from showing by default, either through the API or by a user when\n     show-requested has been subscribed to on the window or 'window-show-requested'\n     on the parent application and the Window.show(force) flag is false.\n     *\n     * @event Window#show-requested\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     */\n    /**\n     * Raised when a window been shown.\n     *\n     * @event Window#shown\n     * @type {object}\n     * @property {string} name - Name of the window.\n     * @property {string} uuid - UUID of the application that the window belongs to.\n     */\n    /**\n     * @typedef {object} legacyWindowIdentity\n     * @summary Object summary\n     * @desc Object description\n     * @property {string} appUuid - The UUID of the application this window entry belongs to.\n     * @property {string} windowName - The name of this window entry.\n     */\n    /**\n     * @typedef {object} preloadScriptState\n     * @summary Object summary\n     * @desc Object description\n     * @property {string} url - The url of the preload script.\n     * @property {string} state - The preload script state:\n     \"load-failed\", \"failed\", \"succeeded\"\n     */\n    constructor(wire, identity) {\n        super(wire, ['window', identity.uuid, identity.name]);\n        this.identity = identity;\n    }\n    // create a new window\n    createWindow(options) {\n        return new Promise((resolve, reject) => {\n            const CONSTRUCTOR_CB_TOPIC = 'fire-constructor-callback';\n            // need to call pageResponse, otherwise when a child window is created, page is not loaded\n            const pageResponse = new Promise((resolve) => {\n                // tslint:disable-next-line\n                this.on(CONSTRUCTOR_CB_TOPIC, function fireConstructor(response) {\n                    let cbPayload;\n                    const success = response.success;\n                    const responseData = response.data;\n                    const message = responseData.message;\n                    if (success) {\n                        cbPayload = {\n                            httpResponseCode: responseData.httpResponseCode,\n                            apiInjected: responseData.apiInjected\n                        };\n                    }\n                    else {\n                        cbPayload = {\n                            message: responseData.message,\n                            networkErrorCode: responseData.networkErrorCode,\n                            stack: responseData.stack\n                        };\n                    }\n                    this.removeListener(CONSTRUCTOR_CB_TOPIC, fireConstructor);\n                    resolve({\n                        message: message,\n                        cbPayload: cbPayload,\n                        success: success\n                    });\n                });\n            });\n            const windowCreation = this.wire.environment.createChildWindow(options);\n            Promise.all([pageResponse, windowCreation]).then((resolvedArr) => {\n                const pageResolve = resolvedArr[0];\n                if (pageResolve.success) {\n                    resolve(this);\n                }\n                else {\n                    reject(pageResolve);\n                }\n            });\n        });\n    }\n    windowListFromNameList(identityList) {\n        const windowList = [];\n        identityList.forEach(identity => {\n            windowList.push(new _Window(this.wire, {\n                uuid: identity.uuid,\n                name: identity.name\n            }));\n        });\n        return windowList;\n    }\n    /**\n     * Retrieves an array of frame info objects representing the main frame and any\n     * iframes that are currently on the page.\n     * @return {Promise.<Array<FrameInfo>>}\n     * @tutorial Window.getAllFrames\n     */\n    getAllFrames() {\n        return this.wire.sendAction('get-all-frames', this.identity).then(({ payload }) => payload.data);\n    }\n    /**\n     * Gets the current bounds (top, left, width, height) of the window.\n     * @return {Promise.<Bounds>}\n     * @tutorial Window.getBounds\n    */\n    getBounds() {\n        return this.wire.sendAction('get-window-bounds', this.identity)\n            // tslint:disable-next-line\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Gives focus to the window.\n     * @return {Promise.<void>}\n     * @emits _Window#focused\n     * @tutorial Window.focus\n     */\n    focus() {\n        return this.wire.sendAction('focus-window', this.identity).then(() => undefined);\n    }\n    /**\n     * Removes focus from the window.\n     * @return {Promise.<void>}\n     * @tutorial Window.blur\n     */\n    blur() {\n        return this.wire.sendAction('blur-window', this.identity).then(() => undefined);\n    }\n    /**\n     * Brings the window to the front of the window stack.\n     * @return {Promise.<void>}\n     * @tutorial Window.bringToFront\n     */\n    bringToFront() {\n        return this.wire.sendAction('bring-window-to-front', this.identity).then(() => undefined);\n    }\n    /**\n     * Performs the specified window transitions.\n     * @param {Transition} transitions - Describes the animations to perform. See the tutorial.\n     * @param {TransitionOptions} options - Options for the animation. See the tutorial.\n     * @return {Promise.<void>}\n     * @tutorial Window.animate\n     */\n    animate(transitions, options) {\n        return this.wire.sendAction('animate-window', Object.assign({}, this.identity, {\n            transitions,\n            options\n        })).then(() => undefined);\n    }\n    /**\n     * Hides the window.\n     * @return {Promise.<void>}\n     * @tutorial Window.hide\n     */\n    hide() {\n        return this.wire.sendAction('hide-window', this.identity).then(() => undefined);\n    }\n    /**\n     * closes the window application\n     * @param { boolean } [force = false] Close will be prevented from closing when force is false and\n     *  close-requested has been subscribed to for applications main window.\n     * @return {Promise.<void>}\n     * @tutorial Window.close\n    */\n    close(force = false) {\n        return this.wire.sendAction('close-window', Object.assign({}, this.identity, { force }))\n            .then(() => {\n            Object.setPrototypeOf(this, null);\n            return undefined;\n        });\n    }\n    /**\n     * Returns then running applications uuid\n     * @return {Promise.<string>}\n     * @tutorial Window.getNativeId\n     */\n    getNativeId() {\n        return this.wire.sendAction('get-window-native-id', this.identity)\n            .then(({ payload }) => payload.data);\n    }\n    /*\n     * @deprecated Use {@link Window.disableUserMovement} instead.\n     */\n    disableFrame() {\n        console.warn('Function is deprecated; use disableUserMovement instead.');\n        return this.wire.sendAction('disable-window-frame', this.identity).then(() => undefined);\n    }\n    /**\n     * Prevents a user from changing a window's size/position when using the window's frame.\n     * @return {Promise.<void>}\n     * @tutorial Window.disableUserMovement\n     */\n    disableUserMovement() {\n        return this.wire.sendAction('disable-window-frame', this.identity).then(() => undefined);\n    }\n    /*\n     * @deprecated Use {@link Window.enableUserMovement} instead.\n     */\n    enableFrame() {\n        console.warn('Function is deprecated; use enableUserMovement instead.');\n        return this.wire.sendAction('enable-window-frame', this.identity).then(() => undefined);\n    }\n    /**\n     * Re-enables user changes to a window's size/position when using the window's frame.\n     * @return {Promise.<void>}\n     * @tutorial Window.enableUserMovement\n     */\n    enableUserMovement() {\n        return this.wire.sendAction('enable-window-frame', this.identity).then(() => undefined);\n    }\n    /**\n     * Executes Javascript on the window, restricted to windows you own or windows owned by\n     * applications you have created.\n     * @param { string } code JavaScript code to be executed on the window.\n     * @return {Promise.<void>}\n     * @tutorial Window.executeJavaScript\n     */\n    executeJavaScript(code) {\n        return this.wire.sendAction('execute-javascript-in-window', Object.assign({}, this.identity, { code }))\n            .then(() => undefined);\n    }\n    /**\n     * Flashes the windows frame and taskbar icon until stopFlashing is called.\n     * @return {Promise.<void>}\n     * @tutorial Window.flash\n     */\n    flash() {\n        return this.wire.sendAction('flash-window', this.identity).then(() => undefined);\n    }\n    /**\n     * Stops the taskbar icon from flashing.\n     * @return {Promise.<void>}\n     * @tutorial Window.stopFlashing\n     */\n    stopFlashing() {\n        return this.wire.sendAction('stop-flash-window', this.identity).then(() => undefined);\n    }\n    /**\n     * Retrieves an array containing wrapped fin.desktop.Windows that are grouped with this\n     * window. If a window is not in a group an empty array is returned. Please note that\n     * calling window is included in the result array.\n     * @return {Promise.<Array<_Window>>}\n     * @tutorial Window.getGroup\n     */\n    getGroup() {\n        return this.wire.sendAction('get-window-group', Object.assign({}, this.identity, {\n            crossApp: true // cross app group supported\n        })).then(({ payload }) => {\n            // tslint:disable-next-line\n            let winGroup = [];\n            if (payload.data.length) {\n                winGroup = this.windowListFromNameList(payload.data);\n            }\n            return winGroup;\n        });\n    }\n    /**\n     * Gets an information object for the window.\n     * @return {Promise.<WindowInfo>}\n     * @tutorial Window.getInfo\n     */\n    getInfo() {\n        return this.wire.sendAction('get-window-info', this.identity).then(({ payload }) => payload.data);\n    }\n    /**\n     * Gets the current settings of the window.\n     * @return {Promise.<any>}\n     * @tutorial Window.getOptions\n     */\n    getOptions() {\n        return this.wire.sendAction('get-window-options', this.identity).then(({ payload }) => payload.data);\n    }\n    /**\n     * Gets the parent application.\n     * @return {Promise.<Application>}\n     * @tutorial Window.getParentApplication\n     */\n    getParentApplication() {\n        return Promise.resolve(new application_1.Application(this.wire, this.identity));\n    }\n    /**\n     * Gets the parent window.\n     * @return {Promise.<_Window>}\n     * @tutorial Window.getParentWindow\n     */\n    getParentWindow() {\n        return Promise.resolve(new application_1.Application(this.wire, this.identity)).then(app => app.getWindow());\n    }\n    /**\n     * Gets a base64 encoded PNG snapshot of the window or just part a of it.\n     * @param { Area } [area] The area of the window to be captured.\n     * Omitting it will capture the whole visible window.\n     * @return {Promise.<string>}\n     * @tutorial Window.getSnapshot\n     */\n    async getSnapshot(area) {\n        const req = Object.assign({}, this.identity, { area });\n        const res = await this.wire.sendAction('get-window-snapshot', req);\n        return res.payload.data;\n    }\n    /**\n     * Gets the current state (\"minimized\", \"maximized\", or \"restored\") of the window.\n     * @return {Promise.<string>}\n     * @tutorial Window.getState\n     */\n    getState() {\n        return this.wire.sendAction('get-window-state', this.identity).then(({ payload }) => payload.data);\n    }\n    /**\n     * Determines if the window is currently showing.\n     * @return {Promise.<boolean>}\n     * @tutorial Window.isShowing\n     */\n    isShowing() {\n        return this.wire.sendAction('is-window-showing', this.identity).then(({ payload }) => payload.data);\n    }\n    /**\n     * Joins the same window group as the specified window.\n     * @param { class } target The window whose group is to be joined\n     * @return {Promise.<void>}\n     * @tutorial Window.joinGroup\n     */\n    joinGroup(target) {\n        return this.wire.sendAction('join-window-group', Object.assign({}, this.identity, {\n            groupingUuid: target.identity.uuid,\n            groupingWindowName: target.identity.name\n        })).then(() => undefined);\n    }\n    /**\n     * Reloads the window current page\n     * @return {Promise.<void>}\n     * @tutorial Window.reload\n     */\n    reload(ignoreCache = false) {\n        return this.wire.sendAction('reload-window', Object.assign({}, this.identity, {\n            ignoreCache\n        })).then(() => undefined);\n    }\n    /**\n     * Leaves the current window group so that the window can be move independently of those in the group.\n     * @return {Promise.<void>}\n     * @tutorial Window.leaveGroup\n     */\n    leaveGroup() {\n        return this.wire.sendAction('leave-window-group', this.identity).then(() => undefined);\n    }\n    /**\n     * Maximizes the window\n     * @return {Promise.<void>}\n     * @tutorial Window.maximize\n     */\n    maximize() {\n        return this.wire.sendAction('maximize-window', this.identity).then(() => undefined);\n    }\n    /**\n     * Merges the instance's window group with the same window group as the specified window\n     * @param { class } target The window whose group is to be merged with\n     * @return {Promise.<void>}\n     * @tutorial Window.mergeGroups\n     */\n    mergeGroups(target) {\n        return this.wire.sendAction('merge-window-groups', Object.assign({}, this.identity, {\n            groupingUuid: target.identity.uuid,\n            groupingWindowName: target.identity.name\n        })).then(() => undefined);\n    }\n    /**\n     * Minimizes the window.\n     * @return {Promise.<void>}\n     * @tutorial Window.minimize\n     */\n    minimize() {\n        return this.wire.sendAction('minimize-window', this.identity).then(() => undefined);\n    }\n    /**\n     * Moves the window by a specified amount.\n     * @param { number } deltaLeft The change in the left position of the window\n     * @param { number } deltaTop The change in the top position of the window\n     * @return {Promise.<void>}\n     * @tutorial Window.moveBy\n     */\n    moveBy(deltaLeft, deltaTop) {\n        return this.wire.sendAction('move-window-by', Object.assign({}, this.identity, { deltaLeft, deltaTop })).then(() => undefined);\n    }\n    /**\n     * Moves the window to a specified location.\n     * @param { number } left The left position of the window\n     * @param { number } top The top position of the window\n     * @return {Promise.<void>}\n     * @tutorial Window.moveTo\n     */\n    moveTo(left, top) {\n        return this.wire.sendAction('move-window', Object.assign({}, this.identity, { left, top })).then(() => undefined);\n    }\n    /**\n     * Resizes the window by a specified amount.\n     * @param { number } deltaWidth The change in the width of the window\n     * @param { number } deltaHeight The change in the height of the window\n     * @param { AnchorType } anchor Specifies a corner to remain fixed during the resize.\n     * Can take the values: \"top-left\", \"top-right\", \"bottom-left\", or \"bottom-right\".\n     * If undefined, the default is \"top-left\"\n     * @return {Promise.<void>}\n     * @tutorial Window.resizeBy\n     */\n    resizeBy(deltaWidth, deltaHeight, anchor) {\n        return this.wire.sendAction('resize-window-by', Object.assign({}, this.identity, {\n            deltaWidth: Math.floor(deltaWidth),\n            deltaHeight: Math.floor(deltaHeight),\n            anchor\n        })).then(() => undefined);\n    }\n    /**\n     * Resizes the window to the specified dimensions.\n     * @param { number } width The change in the width of the window\n     * @param { number } height The change in the height of the window\n     * @param { AnchorType } anchor Specifies a corner to remain fixed during the resize.\n     * Can take the values: \"top-left\", \"top-right\", \"bottom-left\", or \"bottom-right\".\n     * If undefined, the default is \"top-left\"\n     * @return {Promise.<void>}\n     * @tutorial Window.resizeTo\n     */\n    resizeTo(width, height, anchor) {\n        return this.wire.sendAction('resize-window', Object.assign({}, this.identity, {\n            width: Math.floor(width),\n            height: Math.floor(height),\n            anchor\n        })).then(() => undefined);\n    }\n    /**\n     * Restores the window to its normal state (i.e., unminimized, unmaximized).\n     * @return {Promise.<void>}\n     * @tutorial Window.restore\n     */\n    restore() {\n        return this.wire.sendAction('restore-window', this.identity).then(() => undefined);\n    }\n    /**\n     * Will bring the window to the front of the entire stack and give it focus.\n     * @return {Promise.<void>}\n     * @tutorial Window.setAsForeground\n     */\n    setAsForeground() {\n        return this.wire.sendAction('set-foreground-window', this.identity).then(() => undefined);\n    }\n    /**\n     * Sets the window's size and position.\n     * @property { Bounds } bounds This is a * @type {string} name - name of the window.object that holds the propertys of\n     * @return {Promise.<void>}\n     * @tutorial Window.setBounds\n     */\n    setBounds(bounds) {\n        return this.wire.sendAction('set-window-bounds', Object.assign({}, this.identity, bounds)).then(() => undefined);\n    }\n    /**\n     * Shows the window if it is hidden.\n     * @param { boolean } [force = false] Show will be prevented from showing when force is false and\n     *  show-requested has been subscribed to for applications main window.\n     * @return {Promise.<void>}\n     * @tutorial Window.show\n     */\n    show(force = false) {\n        return this.wire.sendAction('show-window', Object.assign({}, this.identity, { force })).then(() => undefined);\n    }\n    /**\n     * Shows the window if it is hidden at the specified location.\n     * If the toggle parameter is set to true, the window will\n     * alternate between showing and hiding.\n     * @param { number } left The left position of the window\n     * @param { number } top The right position of the window\n     * @param { boolean } force Show will be prevented from closing when force is false and\n     * show-requested has been subscribed to for applications main window\n     * @return {Promise.<void>}\n     * @tutorial Window.showAt\n     */\n    showAt(left, top, force = false) {\n        return this.wire.sendAction('show-at-window', Object.assign({}, this.identity, {\n            force,\n            left: Math.floor(left),\n            top: Math.floor(top)\n        })).then(() => undefined);\n    }\n    /**\n     * Shows the Chromium Developer Tools\n     * @return {Promise.<void>}\n     * @tutorial Window.showDeveloperTools\n     */\n    showDeveloperTools() {\n        return this.wire.sendAction('show-developer-tools', this.identity).then(() => undefined);\n    }\n    /**\n     * Updates the window using the passed options\n     * @param {*} options Changes a window's options that were defined upon creation. See tutorial\n     * @return {Promise.<void>}\n     * @tutorial Window.updateOptions\n     */\n    updateOptions(options) {\n        return this.wire.sendAction('update-window-options', Object.assign({}, this.identity, { options })).then(() => undefined);\n    }\n    /**\n     * Provides credentials to authentication requests\n     * @param { string } userName userName to provide to the authentication challange\n     * @param { string } password password to provide to the authentication challange\n     * @return {Promise.<void>}\n     * @tutorial Window.authenticate\n     */\n    authenticate(userName, password) {\n        return this.wire.sendAction('window-authenticate', Object.assign({}, this.identity, { userName, password })).then(() => undefined);\n    }\n    /**\n     * Returns the zoom level of the window.\n     * @return {Promise.<number>}\n     * @tutorial Window.getZoomLevel\n     */\n    getZoomLevel() {\n        return this.wire.sendAction('get-zoom-level', this.identity).then(({ payload }) => payload.data);\n    }\n    /**\n     * Sets the zoom level of the window.\n     * @param { number } level The zoom level\n     * @return {Promise.<void>}\n     * @tutorial Window.setZoomLevel\n     */\n    setZoomLevel(level) {\n        return this.wire.sendAction('set-zoom-level', Object.assign({}, this.identity, { level })).then(() => undefined);\n    }\n    /**\n     * Navigates the window to a specified URL.\n     * @param {string} url - The URL to navigate the window to.\n     * @return {Promise.<void>}\n     * @tutorial Window.navigate\n     */\n    navigate(url) {\n        return this.wire.sendAction('navigate-window', Object.assign({}, this.identity, { url })).then(() => undefined);\n    }\n    /**\n     * Navigates the window back one page.\n     * @return {Promise.<void>}\n     * @tutorial Window.navigateBack\n     */\n    navigateBack() {\n        return this.wire.sendAction('navigate-window-back', Object.assign({}, this.identity)).then(() => undefined);\n    }\n    /**\n     * Navigates the window forward one page.\n     * @return {Promise.<void>}\n     * @tutorial window.navigateForward\n     */\n    async navigateForward() {\n        await this.wire.sendAction('navigate-window-forward', Object.assign({}, this.identity));\n    }\n    /**\n     * Stops any current navigation the window is performing.\n     * @return {Promise.<void>}\n     * @tutorial Window.stopNavigation\n     */\n    stopNavigation() {\n        return this.wire.sendAction('stop-window-navigation', Object.assign({}, this.identity)).then(() => undefined);\n    }\n}\nexports._Window = _Window;\n\n\n//# sourceURL=webpack:///./src/api/window/window.ts?");

/***/ }),

/***/ "./src/environment/openfin-env.ts":
/*!****************************************!*\
  !*** ./src/environment/openfin-env.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst transport_errors_1 = __webpack_require__(/*! ../transport/transport-errors */ \"./src/transport/transport-errors.ts\");\nclass OpenFinEnvironment {\n    constructor() {\n        this.writeToken = (path, token) => {\n            throw new transport_errors_1.NotImplementedError('Not Implemented');\n        };\n        this.retrievePort = (config) => {\n            throw new transport_errors_1.NotImplementedError('Not Implemented');\n        };\n        this.getNextMessageId = () => {\n            return fin.desktop.getUuid();\n        };\n        this.createChildWindow = (options) => {\n            return new Promise((resolve, reject) => {\n                const { uuid: parentUuid } = fin.__internal_.initialOptions;\n                const opt = JSON.parse(JSON.stringify(options));\n                const ABOUT_BLANK = 'about:blank';\n                if (!name || typeof name !== 'string') {\n                    return reject(new Error('Window must have a name'));\n                }\n                opt.uuid = opt.uuid || parentUuid;\n                opt.url = opt.url || ABOUT_BLANK;\n                if (opt.uuid !== parentUuid) {\n                    return reject(new Error('Child window uuid must match the parent window\\'s uuid: ' + parentUuid));\n                }\n                if (this.isWindowExists(opt.uuid, opt.name)) {\n                    return reject(new Error('Trying to create a window that already exists'));\n                }\n                // we should register the window name with the core asap to prevent\n                // multiple windows claiming the same uuid-name combo\n                fin.__internal_.registerWindowName(opt.uuid, opt.name);\n                if (opt.url !== ABOUT_BLANK) {\n                    opt.url = this.resolveUrl(opt.url);\n                }\n                fin.__internal_.createChildWindow(opt, (childWin) => {\n                    resolve(childWin);\n                });\n            });\n        };\n        this.getRandomId = () => {\n            const intArray = new Uint32Array(1);\n            return window.crypto.getRandomValues(intArray)[0].toString(32);\n        };\n        this.isWindowExists = (uuid, name) => {\n            return fin.__internal_.windowExists(uuid, name);\n        };\n    }\n    resolveUrl(url) {\n        const newUrl = new URL(url, location.href);\n        return newUrl.href;\n    }\n}\nexports.default = OpenFinEnvironment;\n\n\n//# sourceURL=webpack:///./src/environment/openfin-env.ts?");

/***/ }),

/***/ "./src/environment/openfin-renderer-api.ts":
/*!*************************************************!*\
  !*** ./src/environment/openfin-renderer-api.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//TODO: IPC gets deleted by the javascript adapter at the moment.\nexports.ipc = fin.__internal_.ipc;\nexports.routingId = fin.__internal_.routingId;\nexports.CORE_MESSAGE_CHANNEL = fin.__internal_.ipcconfig.channels.CORE_MESSAGE;\nexports.outboundTopic = 'of-window-message';\nexports.inboundTopic = `${exports.CORE_MESSAGE_CHANNEL}-${exports.routingId}`;\nexports.currentWindowIdentity = fin.__internal_.getWindowIdentity();\n\n\n//# sourceURL=webpack:///./src/environment/openfin-renderer-api.ts?");

/***/ }),

/***/ "./src/of-main.ts":
/*!************************!*\
  !*** ./src/of-main.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fin_1 = __webpack_require__(/*! ./api/fin */ \"./src/api/fin.ts\");\nconst openfin_renderer_api_1 = __webpack_require__(/*! ./environment/openfin-renderer-api */ \"./src/environment/openfin-renderer-api.ts\");\nconst transport_1 = __webpack_require__(/*! ./transport/transport */ \"./src/transport/transport.ts\");\nconst elipc_1 = __webpack_require__(/*! ./transport/elipc */ \"./src/transport/elipc.ts\");\nconst openfin_env_1 = __webpack_require__(/*! ./environment/openfin-env */ \"./src/environment/openfin-env.ts\");\nconst environment = new openfin_env_1.default();\nconst transport = new transport_1.default(elipc_1.default, environment);\ntransport.connectSync(Object.assign({}, openfin_renderer_api_1.currentWindowIdentity));\nwindow.fin = Object.assign(window.fin, new fin_1.default(transport));\n\n\n//# sourceURL=webpack:///./src/of-main.ts?");

/***/ }),

/***/ "./src/transport/elipc.ts":
/*!********************************!*\
  !*** ./src/transport/elipc.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst wire_1 = __webpack_require__(/*! ./wire */ \"./src/transport/wire.ts\");\nconst transport_errors_1 = __webpack_require__(/*! ./transport-errors */ \"./src/transport/transport-errors.ts\");\nconst openfin_renderer_api_1 = __webpack_require__(/*! ../environment/openfin-renderer-api */ \"./src/environment/openfin-renderer-api.ts\");\nclass ElIPCTransport extends events_1.EventEmitter {\n    constructor(onmessage) {\n        super();\n        this.wire = openfin_renderer_api_1.ipc;\n        this.connectSync = () => {\n            openfin_renderer_api_1.ipc.on(openfin_renderer_api_1.inboundTopic, (sender, data) => {\n                try {\n                    this.onmessage(JSON.parse(data));\n                }\n                catch (err) {\n                    //Do something of value here.\n                    throw err;\n                }\n            });\n        };\n        this.connect = (address) => {\n            throw new transport_errors_1.NotImplementedError('Not Implemented');\n        };\n        this.onmessage = onmessage;\n    }\n    send(data, flags) {\n        openfin_renderer_api_1.ipc.send(openfin_renderer_api_1.routingId, openfin_renderer_api_1.outboundTopic, data);\n        return Promise.resolve();\n    }\n    shutdown() {\n        return Promise.reject('Not Implemented');\n    }\n}\nElIPCTransport.READY_STATE = wire_1.READY_STATE;\nexports.default = ElIPCTransport;\n\n\n//# sourceURL=webpack:///./src/transport/elipc.ts?");

/***/ }),

/***/ "./src/transport/transport-errors.ts":
/*!*******************************************!*\
  !*** ./src/transport/transport-errors.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst wire_1 = __webpack_require__(/*! ./wire */ \"./src/transport/wire.ts\");\nclass DisconnectedError extends Error {\n    constructor(readyState) {\n        super('Expected websocket state OPEN but found ' + wire_1.READY_STATE[readyState]);\n        this.readyState = readyState;\n    }\n}\nexports.DisconnectedError = DisconnectedError;\nclass UnexpectedActionError extends Error {\n}\nexports.UnexpectedActionError = UnexpectedActionError;\nclass DuplicateCorrelationError extends Error {\n}\nexports.DuplicateCorrelationError = DuplicateCorrelationError;\nclass NoAckError extends Error {\n}\nexports.NoAckError = NoAckError;\nclass NotImplementedError extends Error {\n}\nexports.NotImplementedError = NotImplementedError;\nclass NotSupportedError extends Error {\n}\nexports.NotSupportedError = NotSupportedError;\nclass RuntimeError extends Error {\n    constructor(data) {\n        const payload = data.payload || data;\n        const { reason, error } = payload;\n        super(reason);\n        this.name = 'RuntimeError';\n        if (error && error.stack) {\n            this.stack = error.stack;\n        }\n    }\n}\nexports.RuntimeError = RuntimeError;\n\n\n//# sourceURL=webpack:///./src/transport/transport-errors.ts?");

/***/ }),

/***/ "./src/transport/transport.ts":
/*!************************************!*\
  !*** ./src/transport/transport.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst wire_1 = __webpack_require__(/*! ./wire */ \"./src/transport/wire.ts\");\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst transport_errors_1 = __webpack_require__(/*! ./transport-errors */ \"./src/transport/transport-errors.ts\");\nconst eventAggregator_1 = __webpack_require__(/*! ../api/events/eventAggregator */ \"./src/api/events/eventAggregator.ts\");\nclass Transport extends events_1.EventEmitter {\n    constructor(wireType, environment) {\n        super();\n        this.wireListeners = new Map();\n        this.topicRefMap = new Map();\n        this.eventAggregator = new eventAggregator_1.EventAggregator();\n        this.messageHandlers = [this.eventAggregator.dispatchEvent];\n        this.connectSync = (config) => {\n            const { uuid, name } = config;\n            this.me = { uuid, name };\n            this.wire.connectSync();\n        };\n        /* `READY_STATE` is an instance var set by `constructor` to reference the `WebTransportSocket.READY_STATE` enum.\n         * This is syntactic sugar that makes the enum accessible through the `wire` property of the various `fin` singletons.\n         * For example, `fin.system.wire.READY_STATE` is a shortcut to `fin.system.wire.wire.constructor.READY_STATE`.\n         * However it is accessed, the enum is useful for interrogating the state of the web socket on send failure.\n         * The `err.readyState` value is passed to the `reject` handler of the promise returned by either of\n         * `sendAction` or `ferryAction`, and hence all the API methods in the various `fin` singletons that call them.\n         * The enum can be used in two distinct ways by the `reject` handler (using `fin.System.getVersion` by way of example):\n         * 1. State name by state value:\n         * fin.system.getVersion().catch(err => { console.log('State:', fin.system.wire.READY_STATE[err.readyState]); });\n         * 2. State value by state name:\n         * fin.system.getVersion().catch(err => { console.log('Closed:', err.readyState === fin.system.wire.READY_STATE.CLOSED); });\n         * Note that `reject` is called when and only when `readyState` is not `OPEN`.\n         */\n        this.READY_STATE = wire_1.READY_STATE;\n        this.wire = new wireType(this.onmessage.bind(this));\n        this.environment = environment;\n        this.sendRaw = this.wire.send.bind(this.wire);\n        this.registerMessageHandler(this.handleMessage.bind(this));\n        this.wire.on('disconnected', () => {\n            for (const [, { reject }] of this.wireListeners) {\n                reject('Remote connection has closed');\n            }\n            this.wireListeners.clear();\n            this.emit('disconnected');\n        });\n    }\n    async connect(config) {\n        if (wire_1.isExistingConnectConfig(config)) {\n            return this.connectByPort(config);\n        }\n        else if (wire_1.isNewConnectConfig(config)) {\n            const port = await this.environment.retrievePort(config);\n            return this.connectByPort(Object.assign({}, config, { address: `ws://localhost:${port}` }));\n        }\n    }\n    async connectByPort(config) {\n        const { address, uuid, name } = config;\n        const reqAuthPayload = Object.assign({}, config, { type: 'file-token' });\n        this.me = { uuid, name };\n        await this.wire.connect(address);\n        const requestExtAuthRet = await this.sendAction('request-external-authorization', {\n            uuid,\n            type: 'file-token'\n        }, true);\n        if (requestExtAuthRet.action !== 'external-authorization-response') {\n            throw new transport_errors_1.UnexpectedActionError(requestExtAuthRet.action);\n        }\n        const token = requestExtAuthRet.payload.token;\n        await this.environment.writeToken(requestExtAuthRet.payload.file, requestExtAuthRet.payload.token);\n        const requestAuthRet = await this.sendAction('request-authorization', reqAuthPayload, true);\n        if (requestAuthRet.action !== 'authorization-response') {\n            throw new transport_errors_1.UnexpectedActionError(requestAuthRet.action);\n        }\n        else if (requestAuthRet.payload.success !== true) {\n            throw new transport_errors_1.RuntimeError(requestAuthRet.payload);\n        }\n        else {\n            return token;\n        }\n    }\n    sendAction(action, payload = {}, uncorrelated = false) {\n        return new Promise((resolve, reject) => {\n            const id = this.environment.getNextMessageId();\n            const msg = {\n                action,\n                payload,\n                messageId: id\n            };\n            return this.wire.send(msg)\n                .then(() => this.addWireListener(id, resolve, reject, uncorrelated))\n                .catch(reject);\n        });\n    }\n    ferryAction(data) {\n        return new Promise((resolve, reject) => {\n            const id = this.environment.getNextMessageId();\n            data.messageId = id;\n            const resolver = (data) => { resolve(data.payload); };\n            return this.wire.send(data)\n                .then(() => this.addWireListener(id, resolver, reject, false))\n                .catch(reject);\n        });\n    }\n    registerMessageHandler(handler) {\n        this.messageHandlers.push(handler);\n    }\n    addWireListener(id, resolve, reject, uncorrelated) {\n        if (uncorrelated) {\n            this.uncorrelatedListener = resolve;\n        }\n        else if (this.wireListeners.has(id)) {\n            reject(new transport_errors_1.DuplicateCorrelationError(String(id)));\n        }\n        else {\n            this.wireListeners.set(id, { resolve, reject });\n        }\n        // Timeout and reject()?\n    }\n    // This method executes message handlers until the _one_ that handles the message (returns truthy) has run\n    onmessage(data) {\n        for (const h of this.messageHandlers) {\n            h.call(null, data);\n        }\n    }\n    handleMessage(data) {\n        // tslint:disable-next-line\n        const id = data.correlationId || NaN;\n        if (!('correlationId' in data)) {\n            if (this.uncorrelatedListener) {\n                this.uncorrelatedListener.call(null, data);\n            }\n            // tslint:disable-next-line\n            this.uncorrelatedListener = () => { };\n        }\n        else if (!this.wireListeners.has(id)) {\n            return false;\n        }\n        else {\n            const { resolve, reject } = this.wireListeners.get(id);\n            if (data.action !== 'ack') {\n                reject(new transport_errors_1.NoAckError(data.action));\n            }\n            else if (!('payload' in data)) {\n                reject(new transport_errors_1.RuntimeError(data));\n            }\n            else if (!data.payload.success) {\n                reject(new transport_errors_1.RuntimeError(data.payload));\n            }\n            else {\n                resolve.call(null, data);\n            }\n            this.wireListeners.delete(id);\n        }\n        return true;\n    }\n}\nexports.default = Transport;\nclass Message {\n}\nexports.Message = Message;\nclass EventMessage {\n}\nexports.EventMessage = EventMessage;\nclass NotificationEventMessage {\n}\nexports.NotificationEventMessage = NotificationEventMessage;\nclass Payload {\n}\nexports.Payload = Payload;\nclass AuthorizationPayload {\n}\nexports.AuthorizationPayload = AuthorizationPayload;\n\n\n//# sourceURL=webpack:///./src/transport/transport.ts?");

/***/ }),

/***/ "./src/transport/wire.ts":
/*!*******************************!*\
  !*** ./src/transport/wire.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isExternalConfig(config) {\n    if (typeof config.manifestUrl === 'string') {\n        return true;\n    }\n}\nexports.isExternalConfig = isExternalConfig;\nfunction isExistingConnectConfig(config) {\n    return hasUuid(config) && typeof config.address === 'string';\n}\nexports.isExistingConnectConfig = isExistingConnectConfig;\nfunction hasUuid(config) {\n    return typeof config.uuid === 'string';\n}\nfunction hasRuntimeVersion(config) {\n    return config.runtime && typeof config.runtime.version === 'string';\n}\nfunction isNewConnectConfig(config) {\n    return hasUuid(config) && hasRuntimeVersion(config);\n}\nexports.isNewConnectConfig = isNewConnectConfig;\nfunction isPortDiscoveryConfig(config) {\n    return (isExternalConfig(config) && hasRuntimeVersion(config)) || isNewConnectConfig(config);\n}\nexports.isPortDiscoveryConfig = isPortDiscoveryConfig;\nfunction isInternalConnectConfig(config) {\n    return isExistingConnectConfig(config) || isNewConnectConfig(config);\n}\nexports.isInternalConnectConfig = isInternalConnectConfig;\nvar READY_STATE;\n(function (READY_STATE) {\n    READY_STATE[READY_STATE[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    READY_STATE[READY_STATE[\"OPEN\"] = 1] = \"OPEN\";\n    READY_STATE[READY_STATE[\"CLOSING\"] = 2] = \"CLOSING\";\n    READY_STATE[READY_STATE[\"CLOSED\"] = 3] = \"CLOSED\"; // The connection is closed.\n})(READY_STATE = exports.READY_STATE || (exports.READY_STATE = {}));\n\n\n//# sourceURL=webpack:///./src/transport/wire.ts?");

/***/ }),

/***/ "./src/util/promises.ts":
/*!******************************!*\
  !*** ./src/util/promises.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction promisify(func) {\n    return (...args) => new Promise((resolve, reject) => {\n        func(...args, (err, val) => err ? reject(err) : resolve(val));\n    });\n}\nexports.promisify = promisify;\nasync function promiseMap(arr, asyncF) {\n    return Promise.all(arr.map(asyncF));\n}\nexports.promiseMap = promiseMap;\nasync function serial(arr) {\n    const ret = [];\n    for (const func of arr) {\n        const next = await func();\n        ret.push(next);\n    }\n    return ret;\n}\nexports.serial = serial;\nasync function promiseMapSerial(arr, func) {\n    return serial(arr.map((value, index, array) => () => func(value, index, array)));\n}\nexports.promiseMapSerial = promiseMapSerial;\n\n\n//# sourceURL=webpack:///./src/util/promises.ts?");

/***/ }),

/***/ "./src/util/ref-counter.ts":
/*!*********************************!*\
  !*** ./src/util/ref-counter.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass RefCoutner {\n    constructor() {\n        this.topicRefMap = new Map();\n    }\n    // returns the ref count after incrementing\n    incRefCount(key) {\n        const refCount = this.topicRefMap.get(key);\n        let returnCount;\n        if (!refCount) {\n            this.topicRefMap.set(key, 1);\n            returnCount = 1;\n        }\n        else {\n            const newRefCount = refCount + 1;\n            returnCount = newRefCount;\n            this.topicRefMap.set(key, newRefCount);\n        }\n        return returnCount;\n    }\n    // returns the ref count after decrementing, or -1 if the key already had no references\n    decRefCount(key) {\n        const refCount = this.topicRefMap.get(key);\n        let returnCount;\n        if (refCount) {\n            const newRefCount = refCount - 1;\n            this.topicRefMap.set(key, newRefCount);\n            returnCount = newRefCount;\n        }\n        else {\n            returnCount = -1;\n        }\n        return returnCount;\n    }\n    // Execute firstAction if it is the first such ref, else execute nonFirstAction.\n    // In either case the return value is that of the action executed\n    // tslint:disable-next-line\n    actOnFirst(key, firstAction, nonFirstAction = () => { }) {\n        const numRefs = this.incRefCount(key);\n        const isFirstRef = numRefs === 1;\n        return isFirstRef ? firstAction() : nonFirstAction();\n    }\n    // Execute lastAction if it is the first such ref, else execute nonLastAction.\n    // In either case the return value is that of the action executed\n    // tslint:disable-next-line\n    actOnLast(key, lastAction, nonLastAction = () => { }) {\n        const numRefs = this.decRefCount(key);\n        const isLastRef = numRefs === 0;\n        return isLastRef ? lastAction() : nonLastAction();\n    }\n}\nexports.default = RefCoutner;\n\n\n//# sourceURL=webpack:///./src/util/ref-counter.ts?");

/***/ })

/******/ });